<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js rust">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust设计模式</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A catalogue of Rust design patterns, anti-patterns and idioms">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> 引言</a></li><li class="chapter-item expanded "><a href="idioms/index.html"><strong aria-hidden="true">2.</strong> 习惯用法</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="idioms/coercion-arguments.html"><strong aria-hidden="true">2.1.</strong> 以借用类型为参数</a></li><li class="chapter-item expanded "><a href="idioms/concat-format.html"><strong aria-hidden="true">2.2.</strong> 用format!连接字符串</a></li><li class="chapter-item expanded "><a href="idioms/ctor.html"><strong aria-hidden="true">2.3.</strong> 构造器</a></li><li class="chapter-item expanded "><a href="idioms/default.html"><strong aria-hidden="true">2.4.</strong> Default 特性</a></li><li class="chapter-item expanded "><a href="idioms/deref.html"><strong aria-hidden="true">2.5.</strong> 将集合视为智能指针</a></li><li class="chapter-item expanded "><a href="idioms/dtor-finally.html"><strong aria-hidden="true">2.6.</strong> 确定性析构</a></li><li class="chapter-item expanded "><a href="idioms/mem-replace.html"><strong aria-hidden="true">2.7.</strong> mem::{take(), replace()}</a></li><li class="chapter-item expanded "><a href="idioms/on-stack-dyn-dispatch.html"><strong aria-hidden="true">2.8.</strong> 栈上动态分发</a></li><li class="chapter-item expanded "><a href="idioms/ffi-intro.html"><strong aria-hidden="true">2.9.</strong> 外部语言接口</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="idioms/ffi-errors.html"><strong aria-hidden="true">2.9.1.</strong> 常见错误处理</a></li><li class="chapter-item expanded "><a href="idioms/ffi-accepting-strings.html"><strong aria-hidden="true">2.9.2.</strong> 接受字符串</a></li><li class="chapter-item expanded "><a href="idioms/ffi-passing-strings.html"><strong aria-hidden="true">2.9.3.</strong> 传递字符串</a></li></ol></li><li class="chapter-item expanded "><a href="idioms/option-iter.html"><strong aria-hidden="true">2.10.</strong> 关于 Option的迭代器</a></li><li class="chapter-item expanded "><a href="idioms/pass-var-to-closure.html"><strong aria-hidden="true">2.11.</strong> 向闭包传递变量</a></li><li class="chapter-item expanded "><a href="idioms/priv-extend.html"><strong aria-hidden="true">2.12.</strong> 留隐私，为扩展</a></li><li class="chapter-item expanded "><a href="idioms/rustdoc-init.html"><strong aria-hidden="true">2.13.</strong> 关于初始化的文档</a></li><li class="chapter-item expanded "><a href="idioms/temporary-mutability.html"><strong aria-hidden="true">2.14.</strong> 临时可变性</a></li></ol></li><li class="chapter-item expanded "><a href="patterns/index.html"><strong aria-hidden="true">3.</strong> 设计模式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="patterns/builder.html"><strong aria-hidden="true">3.1.</strong> 生成器</a></li><li class="chapter-item expanded "><a href="patterns/compose-structs.html"><strong aria-hidden="true">3.2.</strong> 分解结构体</a></li><li class="chapter-item expanded "><a href="patterns/entry.html"><strong aria-hidden="true">3.3.</strong> Entry API</a></li><li class="chapter-item expanded "><a href="patterns/ffi-intro.html"><strong aria-hidden="true">3.4.</strong> 外部语言接口使用</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="patterns/ffi-export.html"><strong aria-hidden="true">3.4.1.</strong> 基于对象的API</a></li><li class="chapter-item expanded "><a href="patterns/ffi-wrappers.html"><strong aria-hidden="true">3.4.2.</strong> 类型合并封装</a></li></ol></li><li class="chapter-item expanded "><a href="patterns/fold.html"><strong aria-hidden="true">3.5.</strong> Fold</a></li><li class="chapter-item expanded "><a href="patterns/interpreter.html"><strong aria-hidden="true">3.6.</strong> 解释器</a></li><li class="chapter-item expanded "><a href="patterns/newtype.html"><strong aria-hidden="true">3.7.</strong> 新类型</a></li><li class="chapter-item expanded "><a href="patterns/RAII.html"><strong aria-hidden="true">3.8.</strong> RAII 守卫</a></li><li class="chapter-item expanded "><a href="patterns/small-crates.html"><strong aria-hidden="true">3.9.</strong> 偏爱更小的库</a></li><li class="chapter-item expanded "><a href="patterns/strategy.html"><strong aria-hidden="true">3.10.</strong> 策略模式</a></li><li class="chapter-item expanded "><a href="patterns/unsafe-mods.html"><strong aria-hidden="true">3.11.</strong> 将不安全置于小模块中</a></li><li class="chapter-item expanded "><a href="patterns/visitor.html"><strong aria-hidden="true">3.12.</strong> 访问者模式</a></li></ol></li><li class="chapter-item expanded "><a href="anti_patterns/index.html"><strong aria-hidden="true">4.</strong> 反模式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="anti_patterns/deny-warnings.html"><strong aria-hidden="true">4.1.</strong> #[deny(warnings)]</a></li><li class="chapter-item expanded "><a href="anti_patterns/deref.html"><strong aria-hidden="true">4.2.</strong> Deref 多态</a></li></ol></li><li class="chapter-item expanded "><a href="functional/index.html"><strong aria-hidden="true">5.</strong> 函数式编程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="functional/paradigms.html"><strong aria-hidden="true">5.1.</strong> 编程范式</a></li></ol></li><li class="chapter-item expanded "><a href="additional_resources/index.html"><strong aria-hidden="true">6.</strong> 补充材料</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="additional_resources/design-principles.html"><strong aria-hidden="true">6.1.</strong> 设计原则</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Rust设计模式</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/rust-unofficial/patterns" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#引言" id="引言">引言</a></h1>
<h2><a class="header" href="#译者注" id="译者注">译者注</a></h2>
<p>本项目源自<a href="https://github.com/rust-unofficial/patterns">rust-unofficial/patterns</a>，遵守原项目的MPL-2.0协议。
本着学习Rust的过程中也为Rust在国内的推广做一点微小的贡献的想法，来动手翻译该书。我尽量保持在不改专业术语的情况下更口语化些，不希望翻译的太过僵硬，希望读者理解，水平有限，翻译错漏之处还请指出。</p>
<h2><a class="header" href="#参加我们" id="参加我们">参加我们</a></h2>
<p>如果你有兴趣参加这本书的编写，请查看<a href="https://github.com/rust-unofficial/patterns/blob/master/CONTRIBUTING.md">contribution guidelines</a>.</p>
<h2><a class="header" href="#设计模式" id="设计模式">设计模式</a></h2>
<p>在开发程序的时候，我们必须要解决很多问题。
一个程序就相当于一个问题的解决方案。
设计模式就相当于一个用来解决很多不同问题的解决方案的集合。
我们将所有这些解决方案集合在一起去解决更大的问题。</p>
<h2><a class="header" href="#rust中的设计模式" id="rust中的设计模式">Rust中的设计模式</a></h2>
<p>有很多问题有相同的形式。
因为Rust不是面向对象的语言，所以设计模式与其他面向对象语言的设计模式也有所不同。
虽然细节上有所不同，但他们还是有很多相同之处：</p>
<ul>
<li><a href="./patterns/index.html">设计模式</a> 是编写软件过程中解决常见问题的方法。</li>
<li><a href="./anti_patterns/index.html">反模式</a> 是解决常见问题的方法。
然而设计模式带给我们好处，反模式却带来更多的问题。</li>
<li><a href="./idioms/index.html">习惯用法</a> 是编码的指导方针。它是社区的共同规范。除非你有明确的理由，      否则就遵守它。</li>
</ul>
<p>TODO: Mention why Rust is a bit special - functional elements, type system,
borrow checker</p>
<h1><a class="header" href="#习惯用法" id="习惯用法">习惯用法</a></h1>
<p><a href="https://en.wikipedia.org/wiki/Programming_idiom">习惯用法</a> 是被社区广泛接受的风格和模式。它们是指导准则。因为其他开发者熟悉习惯用法，所以编写符合习惯用法的代码有助于其他开发者理解发生了什么状况。</p>
<p>计算机理解编译器生成的机器码。
而语言对开发者来说最有用。
所以，我们有编译器这个抽象层，为什么不善加利用语言呢？</p>
<p>记住<a href="https://en.wikipedia.org/wiki/KISS_principle">KISS 准则</a>:让系统保持简单，愚蠢。
该理论认为大多数系统在简单的时候工作的比复杂的时候更好；因此，简单性应该是设计中的黄金准则，应该避免不必要的复杂性。</p>
<blockquote>
<p>代码是给人类看的，不是计算机。</p>
</blockquote>
<h1><a class="header" href="#以借用类型为参数" id="以借用类型为参数">以借用类型为参数</a></h1>
<h2><a class="header" href="#说明" id="说明">说明</a></h2>
<p>当你为函数选择参数类型时，使用带强制隐式转换的目标会增加你代码的复杂度。在这种情况下，函数将会接受更多的输入参数类型。</p>
<p>使用可切片类型或者胖指针类型没有限制。事实上，你应该总是用借用类型（<strong>borrowed type</strong>）,
而不是自有数据类型的借用（<strong>borrowing the owned type</strong>）。
例如<code>&amp;str</code> 而非 <code>&amp;String</code>, <code>&amp;[T]</code> 而非 <code>&amp;Vec&lt;T&gt;</code>, 或者 <code>&amp;T</code> 而非 <code>&amp;Box&lt;T&gt;</code>.</p>
<p>当自有数据结构（owned type）的实例已经提供了一个访问数据的间接层时，使用借用类型可以让你避免增加间接层。举例来说，<code>String</code>类型有一层间接层，所以<code>&amp;String</code>将有两个间接层。我们可以用<code>&amp;Str</code>来避免这种情况，无论何时调用函数，强制<code>&amp;String</code>转换为<code>&amp;Str</code>。</p>
<h2><a class="header" href="#例子" id="例子">例子</a></h2>
<p>在这个例子中，我们将说明使用<code>&amp;String</code>与<code>&amp;Str</code>作为函数参数的区别。这个思路用于对比<code>&amp;Vec&lt;T&gt;</code> 和 <code>&amp;[T]</code>、 <code>&amp;T</code>和<code>&amp;Box&lt;T&gt;</code>也适用。</p>
<p>考虑一个我们想要确定一个单词是否包含3个连续的元音字母的例子。我们不需要获得字符串的所有权，所以我们将获取一个引用。</p>
<p>代码如下:</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn three_vowels(word: &amp;String) -&gt; bool {
    let mut vowel_count = 0;
    for c in word.chars() {
        match c {
            'a' | 'e' | 'i' | 'o' | 'u' =&gt; {
                vowel_count += 1;
                if vowel_count &gt;= 3 {
                    return true
                }
            }
            _ =&gt; vowel_count = 0
        }
    }
    false
}

fn main() {
    let ferris = &quot;Ferris&quot;.to_string();
    let curious = &quot;Curious&quot;.to_string();
    println!(&quot;{}: {}&quot;, ferris, three_vowels(&amp;ferris));
    println!(&quot;{}: {}&quot;, curious, three_vowels(&amp;curious));

    // 至此运行正常，但下面两行就会失败:
    // println!(&quot;Ferris: {}&quot;, three_vowels(&quot;Ferris&quot;));
    // println!(&quot;Curious: {}&quot;, three_vowels(&quot;Curious&quot;));

}
</code></pre></pre>
<p>这里能够正常运行是因为我们传的参数是<code>&amp;String</code>类型。最后注释的两行运行失败是因为<code>&amp;str</code>类型不能强制隐式转换为<code>&amp;String</code>类型。我们靠修改参数类型即可轻松解决。</p>
<p>例如,如果我们把函数定义改为:</p>
<pre><code class="language-rust ignore">fn three_vowels(word: &amp;str) -&gt; bool {
</code></pre>
<p>那么两种版本都能编译通过并打印相同的输出。</p>
<pre><code class="language-bash">Ferris: false
Curious: true
</code></pre>
<p>等等，这并不是全部！这里还有点说道。你可能对自己说，这没啥事，我永远不会用<code>&amp;'static str</code>当输入参数（像我们刚刚输入<code>&quot;Ferris&quot;</code>这种情况）。即使不考虑这个特殊例子，你还会发现使用<code>&amp;Str</code>类型将会比<code>&amp;String</code>类型带给你更大的灵活性。</p>
<p>让我们现在考虑一个例子：当给定一个句子，我们需确定句子中是否有单词包含3个连续的元音字母。我们也许应该用刚刚写好的函数来对句子中的每个单词做判断。
An example of this could look like this:</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn three_vowels(word: &amp;str) -&gt; bool {
    let mut vowel_count = 0;
    for c in word.chars() {
        match c {
            'a' | 'e' | 'i' | 'o' | 'u' =&gt; {
                vowel_count += 1;
                if vowel_count &gt;= 3 {
                    return true
                }
            }
            _ =&gt; vowel_count = 0
        }
    }
    false
}

fn main() {
    let sentence_string =
        &quot;Once upon a time, there was a friendly curious crab named Ferris&quot;.to_string();
    for word in sentence_string.split(' ') {
        if three_vowels(word) {
            println!(&quot;{} has three consecutive vowels!&quot;, word);
        }
    }
}
</code></pre></pre>
<p>运行我们<code>&amp;Str</code>参数函数定义版本会输出：</p>
<pre><code class="language-bash">curious has three consecutive vowels!
</code></pre>
<p>然而，使用<code>&amp;String</code>版本的函数无法在这个例子中使用。这是因为字符串的切片是<code>&amp;Str</code>类型而非<code>&amp;String</code>类型，其转换为<code>&amp;String</code>类型不是隐性的，然而<code>&amp;String</code>转换为<code>&amp;Str</code>是低开销且隐性的。</p>
<h2><a class="header" href="#参阅" id="参阅">参阅</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/reference/type-coercions.html">Rust Language Reference on Type Coercions</a></li>
<li>For more discussion on how to handle <code>String</code> and <code>&amp;str</code> see
<a href="https://web.archive.org/web/20201112023149/https://hermanradtke.com/2015/05/03/string-vs-str-in-rust-functions.html">this blog series (2015)</a>
by Herman J. Radtke III</li>
</ul>
<h1><a class="header" href="#用format连接字符串" id="用format连接字符串">用<code>format!</code>连接字符串</a></h1>
<h2><a class="header" href="#说明-1" id="说明-1">说明</a></h2>
<p>对一个可变的<code>String</code>类型对象使用<code>push</code>或者<code>push_str</code>方法，或者用<code>+</code>操作符可以构建字符串。然而，使用<code>format!</code>常常会更方便，尤其是结合字面量和非字面量的时候。</p>
<h2><a class="header" href="#例子-1" id="例子-1">例子</a></h2>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn say_hello(name: &amp;str) -&gt; String {
    // 我们可以手动构建字符串
    // let mut result = &quot;Hello &quot;.to_owned();
    // result.push_str(name);
    // result.push('!');
    // result

    // 但是用format! 更好
    format!(&quot;Hello {}!&quot;, name)
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#优点" id="优点">优点</a></h2>
<p>使用<code>format!</code> 连接字符串通常更加简洁和易于阅读。</p>
<h2><a class="header" href="#缺点" id="缺点">缺点</a></h2>
<p>它通常不是最有效的连接字符串的方法。对一个可变的<code>String</code>类型对象进行一连串的<code>push</code>操作通常是最有效率的（尤其这个字符串已经预先分配了足够的空间）</p>
<h1><a class="header" href="#构造器" id="构造器">构造器</a></h1>
<h2><a class="header" href="#说明-2" id="说明-2">说明</a></h2>
<p>Rust 没有语言层面的构造器。取而代之的是常用一个静态的<code>new</code>方法创建一个对象作为构造器。</p>
<h2><a class="header" href="#例子-2" id="例子-2">例子</a></h2>
<pre><code class="language-rust ignore">// A Rust vector, see liballoc/vec.rs
pub struct Vec&lt;T&gt; {
    buf: RawVec&lt;T&gt;,
    len: usize,
}

impl&lt;T&gt; Vec&lt;T&gt; {
    // 构造一个新的 `Vec&lt;T&gt;`.
    // 注意这是一个静态方法
    // 这个构造器不需要任何参数，但有些需要参数来初始化对象
    pub fn new() -&gt; Vec&lt;T&gt; {
        // Create a new Vec with fields properly initialised.
        Vec {
            // 注意我们这里调用的是RawVec类型的构造器
            buf: RawVec::new(),
            len: 0,
        }
    }
}
</code></pre>
<h2><a class="header" href="#参阅-1" id="参阅-1">参阅</a></h2>
<p><a href="idioms/../patterns/builder.html">生成器模式</a>用于有多种构造对象方式的情况。</p>
<h1><a class="header" href="#default-特性" id="default-特性"><code>Default</code> 特性</a></h1>
<h2><a class="header" href="#说明-3" id="说明-3">说明</a></h2>
<p>许多Rust中的类型有一个构造器。然而，构造器是针对特定类型的。Rust不能抽象出一个代表所有带有<code>new()</code>方法的东西。为了实现这个想法，
一个可被容器和其他泛型使用的<code>Default</code>特性应运而生（如 [<code>Option::unwrap_or_default()</code>）。尤其是一些容器已经在适当的情况下实现了它。</p>
<p>单例容器如 <code>Cow</code>, <code>Box</code> 和 <code>Arc</code>为<code>Default</code>类型实现了<code>Default</code>，
并且可以自动地对每个成员都实现<code>Default</code>的结构体支持<code>#[derive(Default)]</code>。所以越多的类型支持 <code>Default</code>，它就会越有用。</p>
<p>另一方面，构造器能够接受多个参数，而<code>default()</code>方法不能。你甚至可以定义多个不同的函数做多个构造器，但是你最多只能为一个类型实现一种<code>Default</code>的实现。</p>
<h2><a class="header" href="#例子-3" id="例子-3">例子</a></h2>
<pre><pre class="playground"><code class="language-rust edition2018">use std::{path::PathBuf, time::Duration};

// 注意我们可以用自动导出 Default.
#[derive(Default, Debug)]
struct MyConfiguration {
    // Option defaults to None
    output: Option&lt;PathBuf&gt;,
    // Vecs default to empty vector
    search_path: Vec&lt;PathBuf&gt;,
    // Duration defaults to zero time
    timeout: Duration,
    // bool defaults to false
    check: bool,
}

impl MyConfiguration {
    // add setters here
}

fn main() {
    // construct a new instance with default values
    let mut conf = MyConfiguration::default();
    // do something with conf here
    conf.check = true;
    println!(&quot;conf = {:#?}&quot;, conf);
}
</code></pre></pre>
<h2><a class="header" href="#参阅-2" id="参阅-2">参阅</a></h2>
<ul>
<li>The <a href="idioms/ctor.html">constructor</a> idiom is another way to generate instances that may or may
not be &quot;default&quot;</li>
<li>The <a href="https://doc.rust-lang.org/stable/std/default/trait.Default.html"><code>Default</code></a> documentation (scroll down for the list of implementors)</li>
<li><a href="https://doc.rust-lang.org/stable/std/option/enum.Option.html#method.unwrap_or_default"><code>Option::unwrap_or_default()</code></a></li>
<li><a href="https://crates.io/crates/derive-new/"><code>derive(new)</code></a></li>
</ul>
<h1><a class="header" href="#将集合视为智能指针" id="将集合视为智能指针">将集合视为智能指针</a></h1>
<h2><a class="header" href="#说明-4" id="说明-4">说明</a></h2>
<p>使用集合的<code>Deref</code>特性使其像智能指针一样，提供数据的借用或者所有权。</p>
<h2><a class="header" href="#例子-4" id="例子-4">例子</a></h2>
<pre><code class="language-rust ignore">use std::ops::Deref;

struct Vec&lt;T&gt; {
    data: T,
    //..
}

impl&lt;T&gt; Deref for Vec&lt;T&gt; {
    type Target = [T];

    fn deref(&amp;self) -&gt; &amp;[T] {
        //..
    }
}
</code></pre>
<p>一个<code>Vec&lt;T&gt;</code>是一些 <code>T</code>类型的所有权的集合，一个<code>&amp;[T]</code>切片借用了一部分<code>T</code>。为<code>Vec</code>类型实现<code>Deref</code>特性使其可以隐式的从 <code>&amp;Vec&lt;T&gt;</code>转为<code>&amp;[T]</code> ，并且也包括自动解引用的关系搜索。<code>Vec</code>类型大多数方法也对切片适用。</p>
<p>See also <code>String</code> and <code>&amp;str</code>.</p>
<h2><a class="header" href="#出发点" id="出发点">出发点</a></h2>
<p>所有权和借用是Rust语言的核心概念。数据结构必须对这些语法的使用负责才能给用户一个良好的体验。当实现一个拥有数据的数据结构时，提供一个数据借用的接口将带来更大的灵活性。</p>
<h2><a class="header" href="#优点-1" id="优点-1">优点</a></h2>
<p>大部分方法可以只针对借用类型实现，这些实现对自有数据的类型可以隐式地适用。
给用户一个获取借用或所有权的选择。</p>
<h2><a class="header" href="#缺点-1" id="缺点-1">缺点</a></h2>
<p>边界检查时，不考虑仅通过解引用可用的方法和特性，所以对泛型数据结构使用这种模式将会变得复杂。（请看 <code>Borrow</code>和<code>AsRef</code>特性）</p>
<h2><a class="header" href="#讨论" id="讨论">讨论</a></h2>
<p>智能指针和数据集合有相似之处：一个智能指针指向一个对象，一个集合指向许多个对象。从类型系统的角度来看二者有一点区别。一个数据集合拥有数据所有权，也负责删除数据。（包括共享数据所有权，一些借用可能是占用数据的）。一个数据集合如果拥有数据，那么通常来说会提供一个数据的借用方法以便多方使用数据。</p>
<p>大多数智能指针（如 <code>Foo&lt;T&gt;</code>）实现了<code>Deref&lt;Target=T&gt;</code>特性。然而数据集合尝尝解引用为一个自定义类型。<code>[T]</code>和<code>str</code>类型有一些语言支持，
但是通常情况下，这不是必要的。即使<code>Bar</code>时一个动态大小的类型时，<code>Foo&lt;T&gt;</code>也可以实现<code>Deref&lt;Target=Bar&lt;T&gt;&gt;</code>，
并且<code>&amp;Bar&lt;T&gt;</code> 是借用<code>Foo&lt;T&gt;</code>类型数据。</p>
<p>一般来讲，有序数据集合将会实现<code>Index</code> 和<code>Range</code>特性来提供切片语法。其将生成借用。</p>
<h2><a class="header" href="#参阅-3" id="参阅-3">参阅</a></h2>
<p><a href="idioms/../anti_patterns/deref.html">Deref polymorphism anti-pattern</a>.</p>
<p><a href="https://doc.rust-lang.org/std/ops/trait.Deref.html">Documentation for <code>Deref</code> trait</a>.</p>
<h1><a class="header" href="#确定性析构" id="确定性析构">确定性析构</a></h1>
<h2><a class="header" href="#说明-5" id="说明-5">说明</a></h2>
<p>Rust不提供与<code>finally</code>等价的代码块——也就是不管函数怎么结束都会执行的代码。相反，一个对象的析构器将会执行在退出前必须执行的代码。</p>
<h2><a class="header" href="#代码示例" id="代码示例">代码示例</a></h2>
<pre><code class="language-rust ignore">fn bar() -&gt; Result&lt;(), ()&gt; {
    // These don't need to be defined inside the function.
    struct Foo;

    // Implement a destructor for Foo.
    impl Drop for Foo {
        fn drop(&amp;mut self) {
            println!(&quot;exit&quot;);
        }
    }

    // The dtor of _exit will run however the function `bar` is exited.
    let _exit = Foo;
    // Implicit return with `?` operator.
    baz()?;
    // Normal return.
    Ok(())
}
</code></pre>
<h2><a class="header" href="#出发点-1" id="出发点-1">出发点</a></h2>
<p>如果一个函数有多个返回语句，那么在退出时执行析构代码将会是困难且重复的（并且容易产生bug）。使用宏来隐式地退出是一个例外。一个常见的用法是使用<code>?</code>操作符，当结果是<code>Ok</code>的时候继续，当结果是<code>Err</code>的时候返回。<code>?</code>操作符是用来处理异常的一个机制，但是并不像Java的<code>finally</code>，这里不支持在正常情况和异常情况下都执行的代码。发生恐慌（Panicking）也将提前结束函数。</p>
<h2><a class="header" href="#优点-2" id="优点-2">优点</a></h2>
<p>在析构器里的代码退出前总是会被执行，能应对恐慌（panics），提前返回等等。</p>
<h2><a class="header" href="#缺点-2" id="缺点-2">缺点</a></h2>
<p>不保证析构器里的代码一定会被执行。举例来说，函数内有一个死循环或者在退出前函数崩溃的情况。在一个已经发生恐慌(panicking)的线程里再次发生恐慌时，析构器也不会执行代码。因此析构器也不能用于必须确定执行的情景。</p>
<p>这种模式介绍了一些难以注意的隐式代码，即函数在结束时没有显式给出析构器执行代码。因此导致debug的时候更加棘手。</p>
<p>为了确定性，申请一个对象和实现<code>Drop</code>特性增加了很多样板代码。</p>
<h2><a class="header" href="#讨论-1" id="讨论-1">讨论</a></h2>
<p>下面是一些关于如何用对象做终结器（finaliser）的精妙之处。对象在函数结束前必须保持存活，然后就被销毁。这个对象必须是一个值或者独占数据的指针（例如：<code>Box&lt;Foo&gt;</code>）。如果使用一个共享指针（例如<code>Rc</code>），那么终结器的生命周期就比函数更长了。类似地，终结器不应该被转移所有权到他处或者被返回。</p>
<p>终结器必须绑定在变量上，否则当退出临时的作用域时它就会被销毁。如果变量仅用作终结器，变量的名字必须用<code>_</code>开头，否则编译器就会警告这个变量未使用。然而，不要直接用<code>_</code>作为变量名称，这样的话将会立刻销毁这个变量。</p>
<p>在Rust中，析构器在对象离开作用域的时候执行。无论是到达代码块的末端、提前返回亦或是函数恐慌(panic)都属于这种情况。当恐慌发生时，Rust对每个栈帧中的每个对象执行析构器代码。所以析构器即使在函数调用内出现恐慌也能顺利执行。</p>
<p>如果一个析构器在析构时出现了恐慌，这就没啥好办法了，所以Rust不再执行析构，果断终止这个线程。这就意味着Rust并不是绝对保证析构器一定会执行，因此可能会导致资源泄露。</p>
<h2><a class="header" href="#参阅-4" id="参阅-4">参阅</a></h2>
<p><a href="idioms/../patterns/RAII.html">RAII</a>.</p>
<h1><a class="header" href="#用memtake_-replace_在修改枚举变体时保持值的所有权" id="用memtake_-replace_在修改枚举变体时保持值的所有权">用<code>mem::{take(_), replace(_)}</code>在修改枚举变体时保持值的所有权</a></h1>
<h2><a class="header" href="#说明-6" id="说明-6">说明</a></h2>
<p>假设我们有一个至少有两种变体的枚举<code>&amp;mut MyEnum</code>，一种是<code>A { name: String, x: u8 }</code>，另一种是<code>B { name: String }</code>。现在我们想要当x=0时，将A变为B，同时变量除枚举类型变化外其他不变。</p>
<p>我们可以不用克隆<code>name</code>变体即可实现上述操作。</p>
<h2><a class="header" href="#例子-5" id="例子-5">例子</a></h2>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::mem;

enum MyEnum {
    A { name: String, x: u8 },
    B { name: String }
}

fn a_to_b(e: &amp;mut MyEnum) {

    // we mutably borrow `e` here. This precludes us from changing it directly
    // as in `*e = ...`, because the borrow checker won't allow it. Therefore
    // the assignment to `e` must be outside the `if let` clause.
    *e = if let MyEnum::A { ref mut name, x: 0 } = *e {

        // this takes out our `name` and put in an empty String instead
        // (note that empty strings don't allocate).
        // Then, construct the new enum variant (which will
        // be assigned to `*e`, because it is the result of the `if let` expression).
        MyEnum::B { name: mem::take(name) }

    // In all other cases, we return immediately, thus skipping the assignment
    } else { return }
}
<span class="boring">}
</span></code></pre></pre>
<p>这种方法对多种枚举变体也适用:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::mem;

enum MultiVariateEnum {
    A { name: String },
    B { name: String },
    C,
    D
}

fn swizzle(e: &amp;mut MultiVariateEnum) {
    use MultiVariateEnum::*;
    *e = match *e {
        // Ownership rules do not allow taking `name` by value, but we cannot
        // take the value out of a mutable reference, unless we replace it:
        A { ref mut name } =&gt; B { name: mem::take(name) },
        B { ref mut name } =&gt; A { name: mem::take(name) },
        C =&gt; D,
        D =&gt; C
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#出发点-2" id="出发点-2">出发点</a></h2>
<p>当使用枚举的时候，我们可能想要改变枚举变体类型为其他类型。为了通过借用检查器检查，我们将分为两个阶段。在第一阶段，我们查看现有的值然后决定下一步怎么做。第二阶段我们可以修改值。</p>
<p>借用检查器不允许我们拿走<code>name</code>字段的值（因为那总得有有个东西放在那啊）。我们当然可以用<code>.clone()</code>克隆一个<code>name</code>的值，然后把这个克隆的值赋给<code>MyEnum::B</code>，
不过这样就是一个反模式的实例（为了满足借用检查器就用克隆，增大了开销）。综上，我们可以通过仅仅一个可变借用来改变值，避免多余的空间申请。</p>
<p><code>mem::take</code>支持我们交换值，用默认值替换，并且返回原值。对于<code>String</code>类型，默认值是一个空字符串，无需申请空间。因此，我们获取原来的<code>name</code>(作为一个拥有值的变量)，我们可以把它包装成另一个枚举。</p>
<p>注：<code>mem:replace</code>非常相似，不过其允许我们指定要替换的值。可以用它实现<code>mem::take</code>的功能：<code>mem::replace(name,String::new())</code>。</p>
<p>然而，如果我们要使用<code>Option</code>的默认值替换掉枚举变体的值，那么用<code>take()</code>方法还是更习惯和简便的。</p>
<h2><a class="header" href="#优点-3" id="优点-3">优点</a></h2>
<p>看好啦，没有内存申请！同时你在这么做的时候会感觉自己像Indiana Jones。（译者注：没看过夺宝奇兵，没get到梗）</p>
<h2><a class="header" href="#缺点-3" id="缺点-3">缺点</a></h2>
<p>这会变得优点啰嗦。如果错误地重复这个操作将会让你厌恶借用检查器。编译器将无法对替换操作优化，结果是让你觉得相比其他不安全的语言来说性能更低。</p>
<p>此外，<code>take</code>操作需要类型实现<a href="idioms/./default.html"><code>Default</code></a>特性。然而，如果这个类型没有实现<code>Default</code>特性，你还是可以用 <code>mem::replace</code>。</p>
<h2><a class="header" href="#讨论-2" id="讨论-2">讨论</a></h2>
<p>这个模式是只属于Rust的特点。在带GC的语言中，你可以直接用引用来替换。（GC会记录有哪些引用），在像C语言这些低级语言中你可以简单地给指针取个别名然后解决问题。</p>
<p>然而，在Rust中，我们不得不再多做一点工作。一个值只能有一个所有者，所以把值取走后，我们必须再往里面放点东西填充就像印第安纳琼斯一样，用一包沙子替换了宝物。</p>
<h2><a class="header" href="#参阅-5" id="参阅-5">参阅</a></h2>
<p>这在特定情况下可以消除利用克隆通过借用检查器的反模式。</p>
<p>[Clone to satisfy the borrow checker](TODO: Hinges on PR #23)</p>
<h1><a class="header" href="#栈上动态分发" id="栈上动态分发">栈上动态分发</a></h1>
<h2><a class="header" href="#说明-7" id="说明-7">说明</a></h2>
<p>我们可以动态分发多个值，然而为了实现此功能，需要声明多个变量来绑定不同类型的对象。我们可以使用延迟条件初始化（deferred conditional initialization）来扩展生命周期，如下所示：</p>
<h2><a class="header" href="#例子-6" id="例子-6">例子</a></h2>
<pre><pre class="playground"><code class="language-rust edition2018">use std::io;
use std::fs;

<span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
</span><span class="boring">let arg = &quot;-&quot;;
</span>
// 它们必须活的比 `readable`长, 因此先声明:
let (mut stdin_read, mut file_read);

// We need to ascribe the type to get dynamic dispatch.
let readable: &amp;mut dyn io::Read = if arg == &quot;-&quot; {
    stdin_read = io::stdin();
    &amp;mut stdin_read
} else {
    file_read = fs::File::open(arg)?;
    &amp;mut file_read
};

// Read from `readable` here.

<span class="boring">Ok(())
</span><span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#出发点-3" id="出发点-3">出发点</a></h2>
<p>Rust默认是单态的代码。这就意味着对每个类型都要生成相对应的代码并且单独优化。这种模式虽然在热路径（hot path）上执行的很快，但是它空间上将非常臃肿。当性能不是致命关键的时候，我们还是要考虑考虑编译时间和cache的使用。</p>
<p>幸运的是，Rust允许我们使用动态分发，但是我们需要显式的声明。</p>
<h2><a class="header" href="#优点-4" id="优点-4">优点</a></h2>
<p>我们不用在堆上申请任何空间。既不用初始化任何用不上的东西，也不用单态化全部代码，便可同时支持<code>File</code>和<code>Stdin</code>。</p>
<h2><a class="header" href="#缺点-4" id="缺点-4">缺点</a></h2>
<p>这样写代码比使用<code>Box</code>实现的版本需要更多活动部件（moving parts）：</p>
<pre><code class="language-rust ignore">// We still need to ascribe the type for dynamic dispatch.
let readable: Box&lt;dyn io::Read&gt; = if arg == &quot;-&quot; {
    Box::new(io::stdin())
} else {
    Box::new(fs::File::open(arg)?)
};
// Read from `readable` here.
</code></pre>
<h2><a class="header" href="#讨论-3" id="讨论-3">讨论</a></h2>
<p>初学Rust之人通常会学到Rust需要所有变量在使用前需要初始化，所以常会忽略没有用到的变量可能不会初始化的问题。Rust付出大量工作来确保只有初始化过的值在离开作用域时会销毁。</p>
<p>上面这个例子符合我们所有的限制条件：</p>
<ul>
<li>所有的变量都在使用前初始化（这个例子中是借用）</li>
<li>每个变量都只有单一类型。在我们的例子中，<code>stdin</code>对应<code>Stdin</code>类型，<code>file</code>对应<code>File</code>类型，<code>readable</code>对应<code>&amp;mut dyn Read</code>类型</li>
<li>每个借用的值的生命周期都比借用他们的场。</li>
</ul>
<h2><a class="header" href="#参阅-6" id="参阅-6">参阅</a></h2>
<ul>
<li><a href="idioms/dtor-finally.html">Finalisation in destructors</a> and
<a href="idioms/../patterns/RAII.html">RAII guards</a> can benefit from tight control over lifetimes.</li>
<li>For conditionally filled <code>Option&lt;&amp;T&gt;</code>s of (mutable) references, one can
initialize an <code>Option&lt;T&gt;</code> directly and use its <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.as_ref"><code>.as_ref()</code></a> method to get an
optional reference.</li>
</ul>
<h1><a class="header" href="#ffi-习惯用法" id="ffi-习惯用法">FFI 习惯用法</a></h1>
<p>编写FFI的代码本身就是一门学问。
不过，这有一些习惯用法可以使其像指针一样操作，并且避免缺少经验的开发者陷入<code>unsafe</code>Rust的陷阱。</p>
<p>这一章中包括下列能在做FFI时有用的习惯用法：</p>
<ol>
<li><a href="idioms/./ffi-errors.html">常见错误处理</a> - 使用整型代表错误类型以及哨兵返回值（sentinel）。</li>
<li><a href="idioms/./ffi-accepting-strings.html">接受字符串</a> 同时使用最少的unsafe代码。</li>
<li><a href="idioms/./ffi-passing-strings.html">传递字符串</a> 给FFI函数。</li>
</ol>
<h1><a class="header" href="#ffi中的错误处理" id="ffi中的错误处理">FFI中的错误处理</a></h1>
<h2><a class="header" href="#说明-8" id="说明-8">说明</a></h2>
<p>在像C语言这种，错误是用返回码表示的。然而，Rust的类型系统支持通过一个完整的类型来提供更加丰富的错误信息。</p>
<p>下面的实践展示了错误代码的不同类型，以及如何在使用层面上去暴露它们：</p>
<ol>
<li>扁平的枚举（译者注：无实际的成员数据）转换成整型并且作为错误码返回。</li>
<li>结构体枚举应该被转换为一个整型错误码和一个包含详细错误信息的字符串。</li>
<li>自定义错误类型应该被转换为C语言标准下的表示类型。</li>
</ol>
<h2><a class="header" href="#代码示例-1" id="代码示例-1">代码示例</a></h2>
<h3><a class="header" href="#扁平枚举" id="扁平枚举">扁平枚举</a></h3>
<pre><code class="language-rust ignore">enum DatabaseError {
    IsReadOnly = 1, // user attempted a write operation
    IOError = 2, // user should read the C errno() for what it was
    FileCorrupted = 3, // user should run a repair tool to recover it
}

impl From&lt;DatabaseError&gt; for libc::c_int {
    fn from(e: DatabaseError) -&gt; libc::c_int {
        (e as i8).into()
    }
}
</code></pre>
<h3><a class="header" href="#结构体枚举" id="结构体枚举">结构体枚举</a></h3>
<pre><code class="language-rust ignore">pub mod errors {
    enum DatabaseError {
        IsReadOnly,
        IOError(std::io::Error),
        FileCorrupted(String), // message describing the issue
    }

    impl From&lt;DatabaseError&gt; for libc::c_int {
        fn from(e: DatabaseError) -&gt; libc::c_int {
            match e {
                DatabaseError::IsReadOnly =&gt; 1,
                DatabaseError::IOError(_) =&gt; 2,
                DatabaseError::FileCorrupted(_) =&gt; 3,
            }
        }
    }
}

pub mod c_api {
    use super::errors::DatabaseError;

    #[no_mangle]
    pub extern &quot;C&quot; fn db_error_description(
        e: *const DatabaseError
        ) -&gt; *mut libc::c_char {

        let error: &amp;DatabaseError = unsafe {
            // SAFETY: pointer lifetime is greater than the current stack frame
            &amp;*e
        };

        let error_str: String = match error {
            DatabaseError::IsReadOnly =&gt; {
                format!(&quot;cannot write to read-only database&quot;);
            }
            DatabaseError::IOError(e) =&gt; {
                format!(&quot;I/O Error: {}&quot;, e);
            }
            DatabaseError::FileCorrupted(s) =&gt; {
                format!(&quot;File corrupted, run repair: {}&quot;, &amp;s);
            }
        };

        let c_error = unsafe {
            // SAFETY: copying error_str to an allocated buffer with a NUL
            // character at the end
            let mut malloc: *mut u8 = libc::malloc(error_str.len() + 1) as *mut _;

            if malloc.is_null() {
                return std::ptr::null_mut();
            }

            let src = error_str.as_bytes().as_ptr();

            std::ptr::copy_nonoverlapping(src, malloc, error_str.len());

            std::ptr::write(malloc.add(error_str.len()), 0);

            malloc as *mut libc::c_char
        };

        c_error
    }
}
</code></pre>
<h3><a class="header" href="#自定义错误类型" id="自定义错误类型">自定义错误类型</a></h3>
<pre><code class="language-rust ignore">struct ParseError {
    expected: char,
    line: u32,
    ch: u16
}

impl ParseError { /* ... */ }

/* Create a second version which is exposed as a C structure */
#[repr(C)]
pub struct parse_error {
    pub expected: libc::c_char,
    pub line: u32,
    pub ch: u16
}

impl From&lt;ParseError&gt; for parse_error {
    fn from(e: ParseError) -&gt; parse_error {
        let ParseError { expected, line, ch } = e;
        parse_error { expected, line, ch }
    }
}
</code></pre>
<h2><a class="header" href="#优点-5" id="优点-5">优点</a></h2>
<p>这样能确保其他语言能够正确访问错误信息，并且不用为此改动Rust代码的API。（译者注：相当于在错误处理时再封装一层，返回最简单的整型和字符串作为错误信息表示）</p>
<h2><a class="header" href="#缺点-5" id="缺点-5">缺点</a></h2>
<p>这样多写了很多代码，并且有些类型不能很容易地转换成C语言的标准。</p>
<h1><a class="header" href="#接受字符串" id="接受字符串">接受字符串</a></h1>
<h2><a class="header" href="#说明-9" id="说明-9">说明</a></h2>
<p>当通过FFI的指针接受字符串时，有两条需要遵守的原则：</p>
<ol>
<li>保持对外部字符串的借用，而不是直接复制一份。</li>
<li>在转换数据类型时最小化<code>unsafe</code>的代码区域。</li>
</ol>
<h2><a class="header" href="#出发点-4" id="出发点-4">出发点</a></h2>
<p>Rust有对C语言风格字符串的内置支持，如<code>CString</code>和<code>CStr</code>类型。然而，有多种不同途径接受外部传入的字符串。</p>
<p>最佳实现是很简单的：用<code>CStr</code>最小化unsafe的代码区域，然后创建一个借用的切片。如果需要拥有其所有权的<code>String</code>，对字符串切片调用<code>to_string()</code>方法。</p>
<h2><a class="header" href="#代码示例-2" id="代码示例-2">代码示例</a></h2>
<pre><code class="language-rust ignore">pub mod unsafe_module {

    // other module content

    #[no_mangle]
    pub extern &quot;C&quot; fn mylib_log(msg: *const libc::c_char, level: libc::c_int) {
        let level: crate::LogLevel = match level { /* ... */ };

        let msg_str: &amp;str = unsafe {
            // SAFETY: accessing raw pointers expected to live for the call,
            // and creating a shared reference that does not outlive the current
            // stack frame.
            match std::ffi::CStr::from_ptr(msg).to_str() {
                Ok(s) =&gt; s,
                Err(e) =&gt; {
                    crate::log_error(&quot;FFI string conversion failed&quot;);
                    return;
                }
            }
        };

        crate::log(msg_str, level);
    }
}
</code></pre>
<h2><a class="header" href="#优点-6" id="优点-6">优点</a></h2>
<p>样例能保证下面两点：</p>
<ol>
<li><code>unsafe</code>代码块尽可能的小。</li>
<li>无法记录生命周期的指针转变为可以记录追踪的共享引用。</li>
</ol>
<p>考虑另一种实现，也就是字符串被实际拷贝一份的情况：</p>
<pre><code class="language-rust ignore">pub mod unsafe_module {

    // other module content

    pub extern &quot;C&quot; fn mylib_log(msg: *const libc::c_char, level: libc::c_int) {
        // DO NOT USE THIS CODE.
        // IT IS UGLY, VERBOSE, AND CONTAINS A SUBTLE BUG.

        let level: crate::LogLevel = match level { /* ... */ };

        let msg_len = unsafe { /* SAFETY: strlen is what it is, I guess? */
            libc::strlen(msg)
        };

        let mut msg_data = Vec::with_capacity(msg_len + 1);

        let msg_cstr: std::ffi::CString = unsafe {
            // SAFETY: copying from a foreign pointer expected to live
            // for the entire stack frame into owned memory
            std::ptr::copy_nonoverlapping(msg, msg_data.as_mut(), msg_len);

            msg_data.set_len(msg_len + 1);

            std::ffi::CString::from_vec_with_nul(msg_data).unwrap()
        }

        let msg_str: String = unsafe {
            match msg_cstr.into_string() {
                Ok(s) =&gt; s,
                Err(e) =&gt; {
                    crate::log_error(&quot;FFI string conversion failed&quot;);
                    return;
                }
            }
        };

        crate::log(&amp;msg_str, level);
    }
}
</code></pre>
<p>这份代码与第一版相比有两个方面缺点:</p>
<ol>
<li>有更多的<code>unsafe</code>代码，更加不灵活。</li>
<li>由于调用大量的算法，这个版本有一个会导致Rust的未定义行为（<code>undefined behaviour</code>）的bug。</li>
</ol>
<p>这里的bug是一个简单的指针计算的错误：字符串被拷贝走<code>msg_len</code>个字节。然而没有包括在末尾的<code>NUL</code>终止符。</p>
<p>向量长度将会被设置为未做填充字符串的长度而不是末尾填一个0的调整后大小。因此，向量内的最后一个字节是没有初始化的内存。当最终创建<code>CString</code>时，其读取向量将会导致未定义行为！</p>
<p>像很多问题一样，这是很难查到的。有些时候它因为字符串不是<code>UTF-8</code>编码而产生恐慌，有时它又会在末尾放一个奇怪的字符，有时它会完全崩溃掉。</p>
<h2><a class="header" href="#缺点-6" id="缺点-6">缺点</a></h2>
<p>或许没有？</p>
<h1><a class="header" href="#传递字符串" id="传递字符串">传递字符串</a></h1>
<h2><a class="header" href="#说明-10" id="说明-10">说明</a></h2>
<p>当传递字符串给FFI函数时，有以下4点需要遵守的原则：</p>
<ol>
<li>让拥有的字符串生命周期尽可能长。</li>
<li>在转换时保持最小化<code>unsafe</code>区域代码。</li>
<li>如果C语言代码会修改字符串数据，那么使用<code>Vec</code>类型而不是<code>CString</code>。</li>
<li>除非外部函数的API需要字符串的所有权，否则不要传给被调用的函数。</li>
</ol>
<h2><a class="header" href="#出发点-5" id="出发点-5">出发点</a></h2>
<p>Rust有对C语言风格字符串的内置支持，如<code>CString</code>和<code>CStr</code>类型。不过，有多种不同途径从Rust函数传给FFI函数字符串的方法。</p>
<p>最佳实现是很简单的：用<code>CSring</code>最小化unsafe的代码区域。然而，第二个警告是<em>对象必须生存足够长时间</em>，意味着生命周期应该最大化。此外，在修改后双向传递<code>CStirng</code>类型的对象是未定义行为，这种情况需要额外的操作来完善。</p>
<h2><a class="header" href="#代码示例-3" id="代码示例-3">代码示例</a></h2>
<pre><code class="language-rust ignore">pub mod unsafe_module {

    // other module content

    extern &quot;C&quot; {
        fn seterr(message: *const libc::c_char);
        fn geterr(buffer: *mut libc::c_char, size: libc::c_int) -&gt; libc::c_int;
    }

    fn report_error_to_ffi&lt;S: Into&lt;String&gt;&gt;(
        err: S
    ) -&gt; Result&lt;(), std::ffi::NulError&gt;{
        let c_err = std::ffi::CString::new(err.into())?;

        unsafe {
            // SAFETY: calling an FFI whose documentation says the pointer is
            // const, so no modification should occur
            seterr(c_err.as_ptr());
        }

        Ok(())
        // The lifetime of c_err continues until here
    }

    fn get_error_from_ffi() -&gt; Result&lt;String, std::ffi::IntoStringError&gt; {
        let mut buffer = vec![0u8; 1024];
        unsafe {
            // SAFETY: calling an FFI whose documentation implies
            // that the input need only live as long as the call
            let written: usize = geterr(buffer.as_mut_ptr(), 1023).into();

            buffer.truncate(written + 1);
        }

        std::ffi::CString::new(buffer).unwrap().into_string()
    }
}
</code></pre>
<h2><a class="header" href="#优点-7" id="优点-7">优点</a></h2>
<p>样例能保证下面三点：</p>
<ol>
<li><code>unsafe</code>代码块尽可能的小。</li>
<li><code>CString</code>生命周期足够长</li>
<li>类型转换时发生的错误能够尽早地传播出来。</li>
</ol>
<p>一个常见（在文档中很常见）的错误是在代码块的开头部分不定义变量。</p>
<pre><code class="language-rust ignore">pub mod unsafe_module {

    // other module content

    fn report_error&lt;S: Into&lt;String&gt;&gt;(err: S) -&gt; Result&lt;(), std::ffi::NulError&gt; {
        unsafe {
            // SAFETY: whoops, this contains a dangling pointer!
            seterr(std::ffi::CString::new(err.into())?.as_ptr());
        }
        Ok(())
    }
}
</code></pre>
<p>这样的代码会导致悬垂指针，因为<code>CString</code>的生命周期并没有因为创建指针而延长，不像创建一个引用那样。</p>
<p>另一个经常提到的问题是初始化一个全0的1K长度的向量很慢。然而，最新的Rust版本针对这种情况提供了一个宏调用<code>zmalloc</code>，和操作系统能返回全0内存的速度一样快。（真的很快）</p>
<h2><a class="header" href="#缺点-7" id="缺点-7">缺点</a></h2>
<p>或许没有？</p>
<h1><a class="header" href="#关于-option的迭代器" id="关于-option的迭代器">关于 <code>Option</code>的迭代器</a></h1>
<h2><a class="header" href="#说明-11" id="说明-11">说明</a></h2>
<p><code>Option</code>可以被视为一个包含一个0个或者1个元素的容器。特别是它实现了<code>IntoIterator</code>特性，这样我们就可以用来写泛型代码。</p>
<h2><a class="header" href="#示例" id="示例">示例</a></h2>
<p>因为<code>Option</code>实现了<code>IntoIterator</code>特性，它就可以用来当<a href="https://doc.rust-lang.org/std/iter/trait.Extend.html#tymethod.extend"><code>.extend()</code></a>的参数:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let turing = Some(&quot;Turing&quot;);
let mut logicians = vec![&quot;Curry&quot;, &quot;Kleene&quot;, &quot;Markov&quot;];

logicians.extend(turing);

// equivalent to
if let Some(turing_inner) = turing {
    logicians.push(turing_inner);
}
<span class="boring">}
</span></code></pre></pre>
<p>如果你需要将一个<code>Option</code>添加到已有的迭代器后面，你可以用 <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.chain"><code>.chain()</code></a>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let turing = Some(&quot;Turing&quot;);
let logicians = vec![&quot;Curry&quot;, &quot;Kleene&quot;, &quot;Markov&quot;];

for logician in logicians.iter().chain(turing.iter()) {
    println!(&quot;{} is a logician&quot;, logician);
}
<span class="boring">}
</span></code></pre></pre>
<p>注意如果这个<code>Option</code>总是非空的，那么用<a href="https://doc.rust-lang.org/std/iter/fn.once.html"><code>std::iter::once</code></a> 更加合适。</p>
<p>此外，因为<code>Option</code>实现了<code>IntoIterator</code>特性，它就可以用<code>for</code>循环来迭代。这等价于用<code>if let Some(..)</code>，大多数情况下倾向于用后者。</p>
<h2><a class="header" href="#参阅-7" id="参阅-7">参阅</a></h2>
<ul>
<li>
<p><a href="https://doc.rust-lang.org/std/iter/fn.once.html"><code>std::iter::once</code></a> 是一个只产生一个元素的迭代器。这有一个更具可读性的替代品<code>Some(foo).into_iter()</code>。</p>
</li>
<li>
<p><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.filter_map"><code>Iterator::filter_map</code></a>
是 <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.flat_map"><code>Iterator::flat_map</code></a>专注于处理返回值是<code>Option</code>的map函数版本。</p>
</li>
<li>
<p><a href="https://crates.io/crates/ref_slice"><code>ref_slice</code></a> 包提供将<code>Option</code>转换为0个或1个元素的切片的函数。</p>
</li>
<li>
<p><a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option&lt;T&gt;</code>的文档</a></p>
</li>
</ul>
<h1><a class="header" href="#向闭包传递变量" id="向闭包传递变量">向闭包传递变量</a></h1>
<h2><a class="header" href="#说明-12" id="说明-12">说明</a></h2>
<p>默认情况下，闭包从环境中借用捕获。或者你可以用<code>move</code>闭包来将环境的所有权全给闭包。然而，一般情况下你是想传递一部分变量到闭包中，如一些数据的拷贝、传引用或者执行一些其他操作。</p>
<p>这种情况应在不同的作用域里进行变量重绑定。</p>
<h2><a class="header" href="#示例-1" id="示例-1">示例</a></h2>
<p>像这样</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;

let num1 = Rc::new(1);
let num2 = Rc::new(2);
let num3 = Rc::new(3);
let closure = {
    // `num1` is moved
    let num2 = num2.clone();  // `num2` is cloned
    let num3 = num3.as_ref();  // `num3` is borrowed
    move || {
        *num1 + *num2 + *num3;
    }
};
<span class="boring">}
</span></code></pre></pre>
<p>而不是</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;

let num1 = Rc::new(1);
let num2 = Rc::new(2);
let num3 = Rc::new(3);

let num2_cloned = num2.clone();
let num3_borrowed = num3.as_ref();
let closure = move || {
    *num1 + *num2_cloned + *num3_borrowed;
};
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#优点-8" id="优点-8">优点</a></h2>
<p>这样在闭包定义的时候就把哪些是复制的数据搞清楚，这样结束时无论闭包有没有消耗掉这些值，都会及早drop掉。</p>
<p>闭包能用与上下文相同的变量名来用那些复制或者move进来的变量。</p>
<h2><a class="header" href="#缺点-8" id="缺点-8">缺点</a></h2>
<p>增加了闭包内的实现代码行数。</p>
<h1><a class="header" href="#留隐私为扩展" id="留隐私为扩展">留隐私，为扩展</a></h1>
<h2><a class="header" href="#说明-13" id="说明-13">说明</a></h2>
<p>使用私有字段确保结构体日后可以在不破坏API稳定性的情况下进一步扩展。</p>
<h2><a class="header" href="#示例-2" id="示例-2">示例</a></h2>
<pre><code class="language-rust ignore">mod a {
    // Public struct.
    pub struct S {
        pub foo: i32,
        // Private field.
        bar: i32,
    }
}

fn main(s: a::S) {
    // Because S::bar is private, it cannot be named here and we must use `..`
    // in the pattern.
    let a::S { foo: _, ..} = s;
}

</code></pre>
<h2><a class="header" href="#讨论-4" id="讨论-4">讨论</a></h2>
<p>向结构体中增加字段通常是保持向后兼容的。然而，如果调用者用模式匹配来解构这个结构体的实例，他可能对现有结构体内的所有公开字段进行修改，这样就破坏了我们的设计。或者调用者可以对一部分字段赋值，然后在模式里用<code>..</code>来自动增加其他可匹配的字段。使用私有字段至少强迫调用者必须用后一种方法，确保结构体是未来是可以扩展的。</p>
<p>这种实现的缺点是你可能需要增加用不到的变量。你可以用<code>()</code>基类型来确保不增加运行时开销，<code>_</code>作为字段名可以避免没使用变量的编译器警告。</p>
<p>如果Rust支持枚举的私有成员，我们就可以用相同的技巧来对一个枚举增加新的成员。但是不用通配符而是穷尽的模式匹配会导致未实现的问题。私有成员会强迫调用者在模式匹配是加上<code>_</code>通配符。这个问题的常规解决方法是加上<code>#[non_exhaustive]</code>属性。</p>
<h1><a class="header" href="#关于初始化的文档" id="关于初始化的文档">关于初始化的文档</a></h1>
<h2><a class="header" href="#说明-14" id="说明-14">说明</a></h2>
<p>如果一个结构体初始化操作很复杂，当写文档的时候，可以在文档中写一个使用样例的函数。</p>
<h2><a class="header" href="#出发点-6" id="出发点-6">出发点</a></h2>
<p>有时候结构体有多个或者很复杂的参数和一堆方法。每个方法都应该有相应的例子说明。</p>
<p>举例来说:</p>
<pre><code class="language-rust ignore">struct Connection {
    name: String,
    stream: TcpStream,
}

impl Connection {
    /// Sends a request over the connection.
    ///
    /// # Example
    /// ```no_run
    /// # // Boilerplate are required to get an example working.
    /// # let stream = TcpStream::connect(&quot;127.0.0.1:34254&quot;);
    /// # let connection = Connection { name: &quot;foo&quot;.to_owned(), stream };
    /// # let request = Request::new(&quot;RequestId&quot;, RequestType::Get, &quot;payload&quot;);
    /// let response = connection.send_request(request);
    /// assert!(response.is_ok());
    /// ```
    fn send_request(&amp;self, request: Request) -&gt; Result&lt;Status, SendErr&gt; {
        // ...
    }

    /// Oh no, all that boilerplate needs to be repeated here!
    fn check_status(&amp;self) -&gt; Status {
        // ...
    }
}
</code></pre>
<h2><a class="header" href="#示例-3" id="示例-3">示例</a></h2>
<p>不用每次都写初始化的部分，主要写一个以这个结构体为参数的函数的用法即可。</p>
<pre><code class="language-rust ignore">struct Connection {
    name: String,
    stream: TcpStream,
}

impl Connection {
    /// Sends a request over the connection.
    ///
    /// # Example
    /// ```
    /// # fn call_send(connection: Connection, request: Request) {
    /// let response = connection.send_request(request);
    /// assert!(response.is_ok());
    /// # }
    /// ```
    fn send_request(&amp;self, request: Request) {
        // ...
    }
}
</code></pre>
<p><strong>注意</strong>：上面的例子里的 <code>assert!(response.is_ok());</code> 不会真的执行，因为其所在的函数并没有被调用。</p>
<h2><a class="header" href="#优点-9" id="优点-9">优点</a></h2>
<p>这样更简洁。</p>
<h2><a class="header" href="#缺点-9" id="缺点-9">缺点</a></h2>
<p>作为例子的函数不会被真的测试。但是在<code>cargo test</code>的时候还是会检查能不能编译通过。所以这个模式是在需要<code>no_run</code>的时候更能彰显作用，这样写就不必用<code>no_run</code>。</p>
<h2><a class="header" href="#讨论-5" id="讨论-5">讨论</a></h2>
<p>如果不需要断言，那么这种模式就可以很好地工作。</p>
<p>如果需要，另一个方法是创建一个公开的方法来创建用<code>#[doc(hidden)]</code>注释的帮助示例（这样用户就看不见）。因为这是包里的公开API，所以在rustdoc里会显示这个方法。</p>
<h1><a class="header" href="#临时可变性" id="临时可变性">临时可变性</a></h1>
<h2><a class="header" href="#说明-15" id="说明-15">说明</a></h2>
<p>有的时候我们需要准备和处理一些数据，当处理完之后就只会读取而不修改。这种情况可以变量重绑定将其改为不可变的。</p>
<p>也可以在代码块里将处理过程和重定义写在一起。</p>
<h2><a class="header" href="#示例-4" id="示例-4">示例</a></h2>
<p>要求向量在使用前必须排序。</p>
<p>用代码块:</p>
<pre><code class="language-rust ignore">let data = {
    let mut data = get_vec();
    data.sort();
    data
};

// Here `data` is immutable.
</code></pre>
<p>用变量重绑定:</p>
<pre><code class="language-rust ignore">let mut data = get_vec();
data.sort();
let data = data;

// Here `data` is immutable.
</code></pre>
<h2><a class="header" href="#优点-10" id="优点-10">优点</a></h2>
<p>编译器可以确保你之后不会意外修改数据。</p>
<h2><a class="header" href="#缺点-10" id="缺点-10">缺点</a></h2>
<p>多增加了一些本不必要的代码，代码结构更复杂。</p>
<h1><a class="header" href="#设计模式-1" id="设计模式-1">设计模式</a></h1>
<p><a href="https://en.wikipedia.org/wiki/Software_design_pattern">设计模式</a>设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。设计模式是用来描述一门编程语言文化的好标准。设计模式与编程语言息息相关，一门语言中的模式可能在另一种语言中没什么必要，因为语言可能自身特性就能解决问题。或者可能在另一门语言中由于缺少某些特性，压根就实现不了。</p>
<p>设计模式如果滥用，那将会增加程序不必要的复杂性。不过设计模式倒可以用来分享关于一门语言深层次和进阶水平的知识。</p>
<h2><a class="header" href="#rust中的设计模式-1" id="rust中的设计模式-1">Rust中的设计模式</a></h2>
<p>Rust有很多独特的特性。这些特性消除了大量的问题，给我们极大的帮助。有些还是Rust的独特设计模式。</p>
<h2><a class="header" href="#yagni" id="yagni">YAGNI</a></h2>
<p>如果你还不了解这个词，YAGNI是不过早添加功能的缩写（<code>You Aren't Going to Need It</code>）。这是写代码时的重要原则。</p>
<blockquote>
<p>我曾写过的最好的代码是我没写过的代码</p>
</blockquote>
<p>如果我们将YAGNI原则应用到设计模式中，我们可以发现Rust的特性能让我们省掉很多不必要的模式。例如，不再需要<a href="https://en.wikipedia.org/wiki/Strategy_pattern">策略模式</a>。在Rust里可以直接用<a href="https://doc.rust-lang.org/book/traits.html">traits</a>。</p>
<p>TODO: Maybe include some code to illustrate the traits.</p>
<h1><a class="header" href="#生成器" id="生成器">生成器</a></h1>
<h2><a class="header" href="#说明-16" id="说明-16">说明</a></h2>
<p>通过调用生成器来构造对象。</p>
<h2><a class="header" href="#示例-5" id="示例-5">示例</a></h2>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, PartialEq)]
pub struct Foo {
    // Lots of complicated fields.
    bar: String,
}

pub struct FooBuilder {
    // Probably lots of optional fields.
    bar: String,
}

impl FooBuilder {
    pub fn new(/* ... */) -&gt; FooBuilder {
        // Set the minimally required fields of Foo.
        FooBuilder {
            bar: String::from(&quot;X&quot;),
        }
    }

    pub fn name(mut self, bar: String) -&gt; FooBuilder {
        // Set the name on the builder itself, and return the builder by value.
        self.bar = bar;
        self
    }

    // If we can get away with not consuming the Builder here, that is an
    // advantage. It means we can use the FooBuilder as a template for constructing
    // many Foos.
    pub fn build(self) -&gt; Foo {
        // Create a Foo from the FooBuilder, applying all settings in FooBuilder
        // to Foo.
        Foo { bar: self.bar }
    }
}

#[test]
fn builder_test() {
    let foo = Foo {
        bar: String::from(&quot;Y&quot;),
    };
    let foo_from_builder: Foo = FooBuilder::new().name(String::from(&quot;Y&quot;)).build();
    assert_eq!(foo, foo_from_builder);
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#出发点-7" id="出发点-7">出发点</a></h2>
<p>当你需要很多不同的构造器或者构造器有副作用的时候这个模式会有帮助。</p>
<h2><a class="header" href="#优点-11" id="优点-11">优点</a></h2>
<p>将构造方法与其他方法分开。</p>
<p>防止构造器数量过多。</p>
<p>即使构造器本身很复杂，也可以做到封装后一行初始化。</p>
<h2><a class="header" href="#缺点-11" id="缺点-11">缺点</a></h2>
<p>与直接构造一个结构体或者一个简单的构造函数相比，这种方法太复杂。</p>
<h2><a class="header" href="#讨论-6" id="讨论-6">讨论</a></h2>
<p>因为Rust缺少重载功能，所以这种模式在Rust里比其他语言更常见。由于一个方法一个名称不能重载，所以Rust相比于C++、Java来说更不适合写很多构造器。</p>
<p>这种模式经常不是为了作为构造器而设计。例如<a href="https://doc.rust-lang.org/std/process/struct.Command.html"><code>std::process::Command</code></a>
是 <a href="https://doc.rust-lang.org/std/process/struct.Child.html"><code>Child</code></a>的构造器（一个进程）。这种情况下没有使用<code>T</code>和<code>TBuilder</code>命名模式。</p>
<p>下面的例子按值获取和返回。然而更符合人体工程学（以及更效率）的方法是按可变引用获取和返回。借用检查器将会帮助我们。传入传出可变引用将会让我们从下面这种代码：</p>
<pre><code class="language-rust ignore">let mut fb = FooBuilder::new();
fb.a();
fb.b();
let f = fb.build();
</code></pre>
<p>转变为<code>FooBuilder::new().a().b().build()</code> 风格代码。</p>
<h2><a class="header" href="#参阅-8" id="参阅-8">参阅</a></h2>
<ul>
<li><a href="https://web.archive.org/web/20210104103100/https://doc.rust-lang.org/1.12.0/style/ownership/builders.html">Description in the style guide</a></li>
<li><a href="https://crates.io/crates/derive_builder">derive_builder</a>, a crate for automatically
implementing this pattern while avoiding the boilerplate.</li>
<li><a href="patterns/../idioms/ctor.html">Constructor pattern</a> for when construction is simpler.</li>
<li><a href="https://en.wikipedia.org/wiki/Builder_pattern">Builder pattern (wikipedia)</a></li>
<li><a href="https://web.archive.org/web/20210104103000/https://rust-lang.github.io/api-guidelines/type-safety.html#c-builder">Construction of complex values</a></li>
</ul>
<h1><a class="header" href="#分解结构体" id="分解结构体">分解结构体</a></h1>
<h2><a class="header" href="#说明-17" id="说明-17">说明</a></h2>
<p>有时候一个很大的结构体会在借用的时候产生问题——当有多个可变借用（每个只改变其中一部分字段）的时候会相互冲突。解决方法是将这个大结构体分解成更小的结构体，然后再把这些小结构组装成大结构体，这样结构体中的每个部分都可以单独的借用。</p>
<p>这通常在其他方面带来更好的设计：用这种模式可以展露出更小的功能模块。</p>
<h2><a class="header" href="#示例-6" id="示例-6">示例</a></h2>
<p>下面是一个设计出的借用检查器会阻止我们使用结构体的示例：</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct A {
    f1: u32,
    f2: u32,
    f3: u32,
}

fn foo(a: &amp;mut A) -&gt; &amp;u32 { &amp;a.f2 }
fn bar(a: &amp;mut A) -&gt; u32 { a.f1 + a.f3 }

fn baz(a: &amp;mut A) {
    // The later usage of x causes a to be borrowed for the rest of the function.
    let x = foo(a);
    // Borrow checker error:
    // let y = bar(a); // ~ ERROR: cannot borrow `*a` as mutable more than once
                       //          at a time
    println!(&quot;{}&quot;, x);
}
<span class="boring">}
</span></code></pre></pre>
<p>我们可以用前面讲的模式重构A为两个更小的结构体，这样就可以解决借用检查的问题：</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// A is now composed of two structs - B and C.
struct A {
    b: B,
    c: C,
}
struct B {
    f2: u32,
}
struct C {
    f1: u32,
    f3: u32,
}

// These functions take a B or C, rather than A.
fn foo(b: &amp;mut B) -&gt; &amp;u32 { &amp;b.f2 }
fn bar(c: &amp;mut C) -&gt; u32 { c.f1 + c.f3 }

fn baz(a: &amp;mut A) {
    let x = foo(&amp;mut a.b);
    // Now it's OK!
    let y = bar(&amp;mut a.c);
    println!(&quot;{}&quot;, x);
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#出发点-8" id="出发点-8">出发点</a></h2>
<p>TODO Why and where you should use the pattern</p>
<h2><a class="header" href="#优点-12" id="优点-12">优点</a></h2>
<p>这可以让你挣脱借用检查器的限制，常常会带来更好的设计。</p>
<h2><a class="header" href="#缺点-12" id="缺点-12">缺点</a></h2>
<p>需要更多的代码。</p>
<p>有时更小的结构体没有明确的抽象意义，最终导致做出坏设计。这种情况是一种“代码气味”（code smell），表明程序需要重构。</p>
<h2><a class="header" href="#讨论-7" id="讨论-7">讨论</a></h2>
<p>在没有借用检查器的语言里中是不需要这种模式的，所以它是Rust独有的设计模式。不过，将功能分解成更小的单元是很多有名的软件设计原则中都赞同的，这一点与语言无关。</p>
<p>这种模式依赖于Rust的借用检查器能够分清结构体内部的字段。在上面的例子中，借用检查器知道<code>a.b</code>和<code>a.c</code>是相互独立的，就不会尝试去借用整个<code>a</code>。</p>
<h1><a class="header" href="#entry-api" id="entry-api">Entry API</a></h1>
<h2><a class="header" href="#说明-18" id="说明-18">说明</a></h2>
<p>待原文补充</p>
<h2><a class="header" href="#example" id="example">Example</a></h2>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//待原文补充
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#出发点-9" id="出发点-9">出发点</a></h2>
<p>待原文补充</p>
<h2><a class="header" href="#优点-13" id="优点-13">优点</a></h2>
<p>待原文补充</p>
<h2><a class="header" href="#缺点-13" id="缺点-13">缺点</a></h2>
<p>待原文补充</p>
<h2><a class="header" href="#讨论-8" id="讨论-8">讨论</a></h2>
<p>待原文补充</p>
<h2><a class="header" href="#参阅-9" id="参阅-9">参阅</a></h2>
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/0216-collection-views.md">RFC</a>
<a href="https://github.com/rust-lang/rfcs/blob/8e2d3a3341da533f846f61f10335b72c9a9f4740/text/0921-entry_v3.md">RFC</a></p>
<p><a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.entry">Hashmap::entry docs</a></p>
<h1><a class="header" href="#外部语言接口使用" id="外部语言接口使用">外部语言接口使用</a></h1>
<p>编写FFI的代码本身就是一门学问。
不过，这有一些习惯用法可以使其像指针一样操作，并且避免缺少经验的开发者陷入<code>unsafe</code>Rust的陷阱。</p>
<p>这一章中包括下列能在做FFI时有用的设计模式：</p>
<ol>
<li><a href="patterns/./ffi-export.html">基于对象API</a> 设计模式有内存安全的特性，同时有一个安全和非安全代码的清晰边界。</li>
<li><a href="patterns/./ffi-wrappers.html">类型合并到包装器</a>——将多个Rust类型合并到一个不透明的“对象”中。</li>
</ol>
<h1><a class="header" href="#基于对象的api" id="基于对象的api">基于对象的API</a></h1>
<h2><a class="header" href="#说明-19" id="说明-19">说明</a></h2>
<p>当在Rust中设计暴露给其他语言的接口时，有一些与普通的API设计原则相反的重要原则。</p>
<ol>
<li>所有封装类型的所有权应该在Rust一端，由用户管理，并且不对外透明。</li>
<li>所有用来交换的数据类型应该由用户所有，并且对外透明。</li>
<li>库的操作应该是针对封装类型的函数。</li>
<li>所有操作不应该封装成基于结构体的类型，而是<em>出处/生命周期</em>。</li>
</ol>
<h2><a class="header" href="#出发点-10" id="出发点-10">出发点</a></h2>
<p>Rust有内置的FFI与其他语言交互。这种方式为库作者通过不同的ABI提供了兼容C的API方法。（尽管这和我们的做法无关）</p>
<p>设计良好的Rust的FFI遵循C语言API的设计原则，同时尽量减少Rust的设计。下面有三个和任何外部语言API设计的目标：</p>
<ol>
<li>让使用目标语言更简单。</li>
<li>尽量避免API破坏Rust端的内部安全性。</li>
<li>尽量使内存不安全的部分和Rust的未定义行为的部分越少越好。</li>
</ol>
<p>Rust代码必须在与外部语言交互的某个层面之上保持安全。然而，<code>unsafe</code>代码中的每个比特都可能造成bug，或者导致未定义行为。</p>
<p>例如，如果一个指针是错误的，将会导致非法内存访问的错误。但是它如果是任由非安全代码执行的，它将会使堆内存彻底崩溃。</p>
<p>基于对象的API设计设计允许写一些接口代码，来清晰明了地划分<code>safe</code>和<code>unsafe</code>代码间的边界，同时保持良好的内存安全特性。</p>
<h2><a class="header" href="#代码示例-4" id="代码示例-4">代码示例</a></h2>
<p>POSIX标准定义了访问基于文件的数据库的API，如<a href="https://web.archive.org/web/20210105035602/https://www.mankier.com/0p/ndbm.h">DBM</a></p>
<p>以下是一个基于对象的API的绝好示例。</p>
<p>这是一段很容易阅读的涉及FFI的C语言代码。下面的说明将助你把握微妙之处。</p>
<pre><code class="language-C">struct DBM;
typedef struct { void *dptr, size_t dsize } datum;

int     dbm_clearerr(DBM *);
void    dbm_close(DBM *);
int     dbm_delete(DBM *, datum);
int     dbm_error(DBM *);
datum   dbm_fetch(DBM *, datum);
datum   dbm_firstkey(DBM *);
datum   dbm_nextkey(DBM *);
DBM    *dbm_open(const char *, int, mode_t);
int     dbm_store(DBM *, datum, datum, int);
</code></pre>
<p>这个API定义了两种类型：<code>DBM</code>和<code>datum</code>。</p>
<p><code>DBM</code>类型被一个封装类型调用。它包含内部状态并且作为库操作的接入点。</p>
<p>由于不知道<code>DBM</code>类型的大小和内存结构，所以它对用户完全不透明，无法创建这种对象。取而代之的是必须通过调用<code>dbm_open</code>方法，仅会给其中一方一个指针。</p>
<p>这意味着所有的<code>DBM</code>对象被库所有。库掌握其内部内存，而不是用户。用户仅通过<code>open</code>和<code>close</code>来掌控对象的生命周期，以及用其他函数来执行操作。</p>
<p><code>datum</code>类型在前文中被称为用来交换的数据类型。它是用来在用户和库之间传递信息的数据类型。</p>
<p>数据库是用来存储非结构数据的，没有预先定义的长度或意义。作为结果，<code>datum</code>是C中等价于Rust中的切片的类型：一大块字节空间和长度。最大的区别是这里没有类型信息，只有<code>void</code>指针表示。</p>
<p>记住这个头文件是从库的视角来写的。用户有一些自己知道尺寸的类型。但是库并不关心这一点，而且由于C的类型强制转换，任何类型的指针都可以被转换为<code>void</code>。</p>
<p>如前所述，这种类型对用户是<em>透明的</em>。而且这个类型归用户所有。因为里面有指针，所以有些微妙的影响。问题是，谁拥有这个指针指向的数据？</p>
<p>对于最佳的内存安全性来说，答案是用户。但是实际取回一个值时，用户并不知道如何申请内存（因为并不知道值有多长）。库代码将会使用用户访问的堆空间，例如C语言中的<code>malloc</code>和<code>free</code>函数，然后将所有权传给Rust一端。</p>
<p>这看起来都是推测，但实际上C语言中的指针就是这样。在Rust中相当于“用户定义生命周期”。库的用户需要阅读文档来正确使用它。用户需要阅读文档才能正确使用它。也就是说用户做错某些决定，后果无法确定。使出现这种情况最少的关键点是把透明的对象的所有权交出去。</p>
<h2><a class="header" href="#优点-14" id="优点-14">优点</a></h2>
<p>这样可以让用户为内存安全保证所付出的努力最小化：</p>
<ol>
<li>不要在调用函数的时候使用不是由<code>dbm_open</code>返回的指针（将造成非法访问）</li>
<li>不要调用函数的时候使用已经关闭的指针（释放后再使用）</li>
<li>任何<code>datum</code>的<code>dptr</code>必须是空指针或者指向一片合法的内存区域。</li>
</ol>
<p>此外，这也避免了一系列指针错误问题。为了理解原因，让我们深入考虑另一种情况：键值循环（key iteration）。</p>
<p>Rust的迭代器很有名。当实现一个迭代器时，开发者创造了一个生命周期受所有者限制的独立类型，并且实现<code>Iterator</code>特性。</p>
<p>下面是在Rust中如何为<code>DBM</code>实现迭代器的方法：</p>
<pre><code class="language-rust ignore">struct Dbm { ... }

impl Dbm {
    /* ... */
    pub fn keys&lt;'it&gt;(&amp;'it self) -&gt; DbmKeysIter&lt;'it&gt; { ... }
    /* ... */
}

struct DbmKeysIter&lt;'it&gt; {
    owner: &amp;'it Dbm,
}

impl&lt;'it&gt; Iterator for DbmKeysIter&lt;'it&gt; { ... }
</code></pre>
<p>托Rust的福，这样实现干净、符合习惯并且安全。</p>
<p>不过，考虑将API直译过来的情况如下：</p>
<pre><code class="language-rust ignore">#[no_mangle]
pub extern &quot;C&quot; fn dbm_iter_new(owner: *const Dbm) -&gt; *mut DbmKeysIter {
    // THIS API IS A BAD IDEA! For real applications, use object-based design instead.
}
#[no_mangle]
pub extern &quot;C&quot; fn dbm_iter_next(
    iter: *mut DbmKeysIter,
    key_out: *const datum
) -&gt; libc::c_int {
    // THIS API IS A BAD IDEA! For real applications, use object-based design instead.
}
#[no_mangle]
pub extern &quot;C&quot; fn dbm_iter_del(*mut DbmKeysIter) {
    // THIS API IS A BAD IDEA! For real applications, use object-based design instead.
}
</code></pre>
<p>这样的API丢失了一个重要信息：迭代器的生命周期不能长于<code>Dbm</code>对象的生命周期。库的用户将会在某些情况下通过迭代器访问到已经释放的数据，导致读取未初始化内存的错误。</p>
<p>下面用C语言写的例子包含了一个bug，以下将详细说明</p>
<pre><code class="language-C">int count_key_sizes(DBM *db) {
    // DO NOT USE THIS FUNCTION. IT HAS A SUBTLE BUT SERIOUS BUG!
    datum key;
    int len = 0;

    if (!dbm_iter_new(db)) {
        dbm_close(db);
        return -1;
    }

    int l;
    while ((l = dbm_iter_next(owner, &amp;key)) &gt;= 0) { // an error is indicated by -1
        free(key.dptr);
        len += key.dsize;
        if (l == 0) { // end of the iterator
            dbm_close(owner);
        }
    }
    if l &gt;= 0 {
        return -1;
    } else {
        return len;
    }
}
</code></pre>
<p>这个bug是经典bug。当迭代器返回结束循环的标志时将发生：</p>
<ol>
<li>循环条件设置<code>l</code>为0，然后因为<code>0 &gt;= 0</code>进入循环。</li>
<li>长度是递增的，初始化是0。</li>
<li>if条件是true，所以数据库被关闭。这应该有一个break。</li>
<li>循环条件再次执行，导致<code>next</code>访问已经被关闭的对象。</li>
</ol>
<p>这个bug里最坏的部分是什么？如果Rust实现部分比较小心，这段代码在大多数情况下可以使用！如果<code>Dbm</code>对象的内存没有立刻被重用，内部检查将总是失败，导致迭代器返回-1表示错误。但是其将会偶尔地导致段错误，或者更坏，更离谱的内存错误！</p>
<p>这种问题不是单靠Rust所能避免的。从库的角度来看，它将对象放在堆上，返回指向这些对象的指针，然后放弃对生命周期的控制。C语言的部分必须“做的漂亮点”。</p>
<p>开发者必须阅读和理解API文档。虽然有些人认为C语言出现这些问题是意料之中，但是通过一个好的API设计是可以减轻这种风险的。<code>DBM</code>的POSIX标准API是将所有权合并到其根节点来实现的：</p>
<pre><code class="language-C">datum   dbm_firstkey(DBM *);
datum   dbm_nextkey(DBM *);
</code></pre>
<p>像这样，所有的生命周期都被绑在一块了，因此避免了风险。</p>
<h2><a class="header" href="#缺点-14" id="缺点-14">缺点</a></h2>
<p>不过，这样的设计也有一些也需要考虑到的缺点。</p>
<p>首先，API本身的表达力变得更差了。用POSIX标准的DBM，每个对象只有一个迭代器，并且每次调用改变自身状态。尽管它是安全的，但这比几乎任何语言中的迭代器都要严格得多。或许对于其他相关对象，它们的生命周期没有那么多层次，这时这种限制的成本比安全性收益要更大。</p>
<p>其次，根据API各部分之间的关系，可能会涉及大量的设计工作。许多更简单的设计点都有与之相关的设计模式：</p>
<ul>
<li>
<p><a href="patterns/./ffi-wrappers.html">类型合并封装</a> 打包多个Rust类型为一个不透明的对象</p>
</li>
<li>
<p><a href="patterns/../idioms/ffi-errors.html">常见错误处理</a> 讲述使用整型作为错误代码和返回值的哨兵（就像<code>NULL</code>指针一样）</p>
</li>
<li>
<p><a href="patterns/../idioms/ffi-accepting-strings.html">接受字符串</a> 代码的情况下接受字符串，并且更容易成功<a href="patterns/../idioms/ffi-passing-strings.html">传递字符串</a></p>
</li>
</ul>
<p>不过，也不是所有API都可以这样设计。具体情况具体分析。</p>
<h1><a class="header" href="#类型合并封装" id="类型合并封装">类型合并封装</a></h1>
<h2><a class="header" href="#说明-20" id="说明-20">说明</a></h2>
<p>这个模式是被设计用来在最小化内存不安全代码区域的情况下，支持优雅地处理多种相关类型。</p>
<p>Rust的别名规则的基石之一就是生命周期。其确保了多种在类型间的访问模式是内存安全的，也包括安全的数据竞争。</p>
<p>不过当Rust 的类型导出到其他语言时，通常转换为指针。在Rust中，指针相当于“用户管理指针指向对象的生命周期”。谁使用谁负责避免内存不安全的情况。</p>
<p>因此需要对用户代码有一定程度的信任，特别是在释放内存之后，Rust对此无能为力。不过，一些API设计相比于其他设计来说，对另一种语言编写的代码造成更大的负担。</p>
<p>风险最小的API设计是“合并包装器”，所有可能的互动都合并到一个“包装器类型”中，保持Rust的API干净。</p>
<h2><a class="header" href="#代码示例-5" id="代码示例-5">代码示例</a></h2>
<p>为了便于理解，让我们看看一个经典的API导出的例子：在集合中循环访问。</p>
<p>API看起来像这样:</p>
<ol>
<li>迭代器用<code>first_key</code>初始化。</li>
<li>每次调用<code>next_key</code>将会递增迭代器。</li>
<li>Calls to <code>next_key</code> if the iterator is at the end will do nothing.</li>
<li>当迭代器到尾时，调用<code>next_key</code>将什么都不做。</li>
<li>像前面所说，迭代器将会被包装进集合中（不像Rust的原生API）</li>
</ol>
<p>如果迭代器高效实现了<code>nth()</code>，就可以实现对每个函数调用都是很快的：</p>
<pre><code class="language-rust ignore">struct MySetWrapper {
    myset: MySet,
    iter_next: usize,
}

impl MySetWrapper {
    pub fn first_key(&amp;mut self) -&gt; Option&lt;&amp;Key&gt; {
        self.iter_next = 0;
        self.next_key()
    }
    pub fn next_key(&amp;mut self) -&gt; Option&lt;&amp;Key&gt; {
        if let Some(next) = self.myset.keys().nth(self.iter_next) {
            self.iter_next += 1;
            Some(next)
        } else {
            None
        }
    }
}
</code></pre>
<p>因此，包装器实现简单并且不包含任何<code>unsafe</code>代码。</p>
<h2><a class="header" href="#优点-15" id="优点-15">优点</a></h2>
<p>这使得API使用起来更安全，避免了在类型间交互时的生命周期问题。关于更多的优点和避免的陷阱请看 <a href="patterns/./ffi-export.html">基于对象的API</a>。</p>
<h2><a class="header" href="#缺点-15" id="缺点-15">缺点</a></h2>
<p>包装类型常常是困难的，并且有时Rust的API做出妥协将会使事情更容易。</p>
<p>举例来说，想想一个没有高效实现<code>nth()</code>的迭代器。它肯定需要写特殊的逻辑来保证对象处理循环全在内部，或者单独支持一个不同的访问模式仅用来做外部语言访问。</p>
<h3><a class="header" href="#尝试包装迭代器-并且失败了" id="尝试包装迭代器-并且失败了">尝试包装迭代器 (并且失败了)</a></h3>
<p>为了正确地包装类型，包装器将会实现C语言版本的代码要做的事：擦除迭代器的生命周期，手动管理其生命周期。</p>
<p>简单地说，这是离谱的难。</p>
<p>下面仅仅是其中一个陷阱的说明。</p>
<p><code>MySetWrapper</code>的第一个版本像下面这样：</p>
<pre><code class="language-rust ignore">struct MySetWrapper {
    myset: MySet,
    iter_next: usize,
    // created from a transmuted Box&lt;KeysIter + 'self&gt;
    iterator: Option&lt;NonNull&lt;KeysIter&lt;'static&gt;&gt;&gt;,
}
</code></pre>
<p>用<code>transmute</code>来延长生命周期，然后用一个指针来隐藏它，这就够丑陋的。不过它还有更坏的：任何其他的操作将会导致Rust的<code>未定义行为</code>(undefined behavior)。</p>
<p>在包装器内的<code>MySet</code>将会被其他函数在循环时操控，例如存储一个重复的新值。而API无法阻止这一点，并且事实上一些相似的C语言库也预期如此。</p>
<p>一个<code>myset_store</code> 的简单实现如下：</p>
<pre><code class="language-rust ignore">pub mod unsafe_module {

    // other module content

    pub fn myset_store(
        myset: *mut MySetWrapper,
        key: datum,
        value: datum) -&gt; libc::c_int {

        // DO NOT USE THIS CODE. IT IS UNSAFE TO DEMONSTRATE A PROLBEM.

        let myset: &amp;mut MySet = unsafe { // SAFETY: whoops, UB occurs in here!
            &amp;mut (*myset).myset
        };

        /* ...check and cast key and value data... */

        match myset.store(casted_key, casted_value) {
            Ok(_) =&gt; 0,
            Err(e) =&gt; e.into()
        }
    }
}
</code></pre>
<p>当函数调用时迭代器已经存在，我们将违背Rust的一个别名规则。根据Rust的规则，在这段代码中的可变引用必须独占。如果迭代器已经存在，它就不是独占的，所以我们会有<code>未定义行为</code>！<sup class="footnote-reference"><a href="#1">1</a></sup></p>
<p>为了避免这种情况的发生，我们必须有一种确保可变引用独占的方法。这基本相当于当迭代器存在时清除迭代器的共享引用，然后重新创建它。在绝大多数情况下，这还是比C语言版本的效率更低。</p>
<p>一些人可能会问：C语言是如何高效地处理这种情况的？答案是：它作弊。Rust的别名规则是一个问题，但C语言直接用指针完全忽略这个问题。作为交换，
常常能看见一些代码在手册中被声明在某些或所有情况下为非线程安全的。事实上，<a href="https://manpages.debian.org/buster/manpages/attributes.7.en.html">GNU C library</a>
有专门研究并发行为的全部词典。</p>
<p>Rust总是使内存中的一切安全，能同时获得C语言中无法兼得的安全性和性能。被拒绝使用某些捷径是Rust的开发者必须付出的代价。</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>对于那些正在绞尽脑汁的C程序员来说，在这段代码中不需要读取迭代器，因为是未定义行为。排他性规则还支持编译器优化，这可能会导致由于迭代器的共享引用产生不一致的观察结果。（例如栈溢出或者重新排序指令以提高效率）。这些情况将可能在可变引用创建后的任何时间发生。</p>
</div>
<h1><a class="header" href="#fold" id="fold">Fold</a></h1>
<h2><a class="header" href="#说明-21" id="说明-21">说明</a></h2>
<p>对集合中的每个数据执行算法来创建新的项，从而创建一个全新的集合。</p>
<p>这里的词源对我来说是不清晰的。Rust编译器用&quot;fold&quot;和&quot;folder&quot;的说法，即使它对我来说在通常意义上更像是map而不是fold。看下面的讨论了解更多细节。</p>
<h2><a class="header" href="#代码示例-6" id="代码示例-6">代码示例</a></h2>
<pre><code class="language-rust ignore">// The data we will fold, a simple AST.
mod ast {
    pub enum Stmt {
        Expr(Box&lt;Expr&gt;),
        Let(Box&lt;Name&gt;, Box&lt;Expr&gt;),
    }

    pub struct Name {
        value: String,
    }

    pub enum Expr {
        IntLit(i64),
        Add(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
        Sub(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
    }
}

// The abstract folder
mod fold {
    use ast::*;

    pub trait Folder {
        // A leaf node just returns the node itself. In some cases, we can do this
        // to inner nodes too.
        fn fold_name(&amp;mut self, n: Box&lt;Name&gt;) -&gt; Box&lt;Name&gt; { n }
        // Create a new inner node by folding its children.
        fn fold_stmt(&amp;mut self, s: Box&lt;Stmt&gt;) -&gt; Box&lt;Stmt&gt; {
            match *s {
                Stmt::Expr(e) =&gt; Box::new(Stmt::Expr(self.fold_expr(e))),
                Stmt::Let(n, e) =&gt; Box::new(Stmt::Let(self.fold_name(n), self.fold_expr(e))),
            }
        }
        fn fold_expr(&amp;mut self, e: Box&lt;Expr&gt;) -&gt; Box&lt;Expr&gt; { ... }
    }
}

use fold::*;
use ast::*;

// An example concrete implementation - renames every name to 'foo'.
struct Renamer;
impl Folder for Renamer {
    fn fold_name(&amp;mut self, n: Box&lt;Name&gt;) -&gt; Box&lt;Name&gt; {
        Box::new(Name { value: &quot;foo&quot;.to_owned() })
    }
    // Use the default methods for the other nodes.
}
</code></pre>
<p>对AST执行<code>Renamer</code>的结果是创建一个与旧AST相同的AST，但是每个name都改为<code>foo</code>。</p>
<p>folder也可以定义为将一个数据结构映射到不同（但基本相似）的数据结构。例如，我们可以把一个AST转换到一个高级中间代码表示树(HIR Tree)。</p>
<h2><a class="header" href="#出发点-11" id="出发点-11">出发点</a></h2>
<p>通过对数据结构中的每个节点执行一些操作来映射一个数据结构是常见的。对于简单结构上的简单操作，可以用<code>Iterator::map</code>来实现。对于更复杂的操作，或者前面的节点会影响后面节点的操作，或者数据结构上的循环是非平凡的，用fold模式更为妥帖。</p>
<p>类似访问者模式，fold模式允许我们将数据结构的遍历与对每个节点执行的操作分开。</p>
<h2><a class="header" href="#讨论-9" id="讨论-9">讨论</a></h2>
<p>采用这种方式映射数据结构在函数式语言中很常见。在面向对象语言中，更常见的是就地修改数据结构。Rust中常见的是&quot;函数式&quot;的方法，主要是因为引用的不可变性。采用新生成数据结构而不是修改原来的结构，使在大多数情况下对代码推理更容易。</p>
<p>效率和可重用性之间的权衡可以通过改变<code>fold_*</code>方法对节点的接受方式来调整。</p>
<p>在上面的例子里我们通过<code>Box</code>指针来操作。因为独占数据，原始的数据结构不能再被使用。另一方面如果一个节点不再修改，重用它将会更高效。</p>
<p>如果我们对借用的引用进行操作，原来的数据结构就能被重用。不过一个节点哪怕没修改也必须克隆才能保证独占。</p>
<p>使用计数指针可以兼得二者——我们既可以重用原始数据结构并且我们不需要克隆没有被改变的节点。不过这不太符合人体工程学并且意味着数据结构不能是可变的。</p>
<h2><a class="header" href="#参阅-10" id="参阅-10">参阅</a></h2>
<p>迭代器有<code>fold</code>方法，不过这个fold是将数据结构压缩成一个值而不是产生一个新的数据结构。迭代器的<code>map</code>更像是这里说的fold模式。</p>
<p>在其他语言中，更常见的是Rust迭代器中的fold形式而不是这里说的fold模式。一些函数式语言中有对数据结构进行复杂转换的支持。</p>
<p><a href="patterns/visitor.html">访问者模式</a>和fold高度相关。 它们共享遍历数据结构的概念——在每个节点上执行操作。不过访问者模式不创建新的数据结构也不消耗原来的数据。</p>
<h1><a class="header" href="#解释器" id="解释器">解释器</a></h1>
<h2><a class="header" href="#说明-22" id="说明-22">说明</a></h2>
<p>如果一个问题经常出现并且需要很多且重复的步骤来解决，那么问题应该被抽象为一个简单的语言并且一个解释器对象能通过解释这种语言的句子来解决问题。</p>
<p>基本上，对于我们定义的任何类型的问题有如下三点：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Domain-specific_language">领域专用语言</a>，</li>
<li>这种语言的语法,</li>
<li>解决问题实例的解释器</li>
</ul>
<h2><a class="header" href="#出发点-12" id="出发点-12">出发点</a></h2>
<p>我们的目标是转换简单的数学表达式为后缀表达式。（<a href="https://en.wikipedia.org/wiki/Reverse_Polish_notation">逆波兰表达式</a>）。
为简单起见，表达式包含十个数字<code>0</code>,...<code>9</code>和<code>+</code>,<code>-</code>两种操作。举例来说，<code>2 + 4</code>被翻译为<code>2 4 +</code>。</p>
<h2><a class="header" href="#问题的上下文无关文法" id="问题的上下文无关文法">问题的上下文无关文法</a></h2>
<p>我们的任务是将中缀表达式转为后缀表达式。我们对包含<code>0</code>,...<code>9</code>和<code>+</code>,<code>-</code>的中缀表达式定义上下文无关文法包括：</p>
<ul>
<li>终结符号: <code>0</code>, ..., <code>9</code>, <code>+</code>, <code>-</code></li>
<li>非终结符号: <code>exp</code>, <code>term</code></li>
<li>开始符号 <code>exp</code></li>
<li>还有下述的生成规则</li>
</ul>
<pre><code class="language-ignore">exp -&gt; exp + term
exp -&gt; exp - term
exp -&gt; term
term -&gt; 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
</code></pre>
<p>这个语法应该根据我们要用它做什么来进一步转换。举例来说，我们也许需要消除左递归。更多细节请看<a href="https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools">Compilers: Principles,Techniques, and Tools</a></p>
<h2><a class="header" href="#解决方案" id="解决方案">解决方案</a></h2>
<p>我们只需实现一个递归下降解析器。为了简单起见，当表达式语法错误时，代码会恐慌。（例如根据语法定义，<code>2-34</code>或者<code>2+5-</code>是错误的）</p>
<pre><pre class="playground"><code class="language-rust edition2018">pub struct Interpreter&lt;'a&gt; {
    it: std::str::Chars&lt;'a&gt;,
}
impl&lt;'a&gt; Interpreter&lt;'a&gt; {
    pub fn new(infix: &amp;'a str) -&gt; Self {
        Self { it: infix.chars() }
    }
    fn next_char(&amp;mut self) -&gt; Option&lt;char&gt; {
        self.it.next()
    }
    pub fn interpret(&amp;mut self, out: &amp;mut String) {
        self.term(out);
        while let Some(op) = self.next_char() {
            if op == '+' || op == '-' {
                self.term(out);
                out.push(op);
            } else {
                panic!(&quot;Unexpected symbol '{}'&quot;, op);
            }
        }
    }
    fn term(&amp;mut self, out: &amp;mut String) {
        match self.next_char() {
            Some(ch) if ch.is_digit(10) =&gt; out.push(ch),
            Some(ch) =&gt; panic!(&quot;Unexpected symbol '{}'&quot;, ch),
            None =&gt; panic!(&quot;Unexpected end of string&quot;),
        }
    }
}
pub fn main() {
    let mut intr = Interpreter::new(&quot;2+3&quot;);
    let mut postfix = String::new();
    intr.interpret(&amp;mut postfix);
    assert_eq!(postfix, &quot;23+&quot;);
    intr = Interpreter::new(&quot;1-2+3-4&quot;);
    postfix.clear();
    intr.interpret(&amp;mut postfix);
    assert_eq!(postfix, &quot;12-3+4-&quot;);
}
</code></pre></pre>
<h2><a class="header" href="#讨论-10" id="讨论-10">讨论</a></h2>
<p>可能有一种错误的看法，即解释器设计模式是关于形式语言的语法设计和语法分析器的实现。事实上，这个模式是用更具体的方式表达问题实例，并实现解决这些问题实例的函数/类/结构。Rust语言有<code>macro_rules!</code>支持定义特殊语法和如何展开这种语法为源代码的规则。</p>
<p>在下面的例子中我们创建了一个简单的宏来计算n维向量的<a href="https://en.wikipedia.org/wiki/Euclidean_distance">欧式长度</a>。写<code>norm!(x,1,2)</code>也许比打包<code>x,1,2</code>到<code>Vec</code>中然后调用函数计算要更有表达力和效率。</p>
<pre><pre class="playground"><code class="language-rust edition2018">macro_rules! norm {
    ($($element:expr),*) =&gt; {
        {
            let mut n = 0.0;
            $(
                n += ($element as f64)*($element as f64);
            )*
            n.sqrt()
        }
    };
}
fn main() {
    let x = -3f64;
    let y = 4f64;
    assert_eq!(3f64, norm!(x));
    assert_eq!(5f64, norm!(x, y));
    assert_eq!(0f64, norm!(0, 0, 0)); 
    assert_eq!(1f64, norm!(0.5, -0.5, 0.5, -0.5));
}
</code></pre></pre>
<h2><a class="header" href="#see-also" id="see-also">See also</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Interpreter_pattern">解释器模式</a></li>
<li><a href="https://en.wikipedia.org/wiki/Context-free_grammar">上下文无关文法</a></li>
<li><a href="https://doc.rust-lang.org/rust-by-example/macros.html">macro_rules!</a></li>
</ul>
<h1><a class="header" href="#新类型" id="新类型">新类型</a></h1>
<p>如果在某些情况下，我们希望一个类型的行为类似于另一个类型，或者在编译时强制执行某些行为，而仅使用类型别名是不够的呢？</p>
<p>举例来说，如果我们出于安全考虑想要创建一个<code>String</code>的自定义的<code>Display</code>实现（例如密码）。</p>
<p>这种情况我们可以用<code>新类型</code>模式提供类型安全和封装。</p>
<h2><a class="header" href="#说明-23" id="说明-23">说明</a></h2>
<p>用带有单独字段的结构来创建一个类型的不透明包装器。这将创建一个新类型，而不是类型的别名。</p>
<h2><a class="header" href="#代码示例-7" id="代码示例-7">代码示例</a></h2>
<pre><code class="language-rust ignore">// Some type, not necessarily in the same module or even crate.
struct Foo {
    //..
}

impl Foo {
    // These functions are not present on Bar.
    //..
}

// The newtype.
pub struct Bar(Foo);

impl Bar {
    // Constructor.
    pub fn new(
        //..
    ) -&gt; Bar {

        //..

    }

    //..
}

fn main() {
    let b = Bar::new(...);

    // Foo and Bar are type incompatible, the following do not type check.
    // let f: Foo = b;
    // let b: Bar = Foo { ... };
}
</code></pre>
<h2><a class="header" href="#出发点-13" id="出发点-13">出发点</a></h2>
<p>新类型的最初动机是抽象。其允许你在不同类型间共享实现代码并且精准控制接口。通过使用新类型而不是将实现作为API的一部分公开出去，它支持你向后兼容地更改实现。</p>
<p>新类型可以用来区分单位。例如封装<code>f64</code>类型为可辨识的<code>Miles</code>和<code>Kms</code>。</p>
<h2><a class="header" href="#优点-16" id="优点-16">优点</a></h2>
<p>被包装的类型和包装后的类型是不兼容的，所以新类型的用户永远不会困惑于区分这二者的类型。</p>
<p>新类型是零开销抽象——没有运行时负担。</p>
<p>隐私系统确保用户不能访问包装的类型（如果字段是私有的，默认私有）。</p>
<h2><a class="header" href="#缺点-16" id="缺点-16">缺点</a></h2>
<p>新类型的缺点（尤其是与类型别名比较），是没有特殊的语言支持。这就意味着会有大量的啰嗦的样板代码。对于要在包装类型上公开的每个方法，都需要一个穿透的方法，还有对包装器类型的实现来支持每一个想要的特性。</p>
<h2><a class="header" href="#讨论-11" id="讨论-11">讨论</a></h2>
<p>在Rust代码中新类型模式是很常见的。抽象或表达单元是最常见的用法，但他们也可以用于其他原因：</p>
<ul>
<li>限制功能（减少暴露的函数或者特性实现），</li>
<li>使具有复制语义的类型具有移动语义</li>
<li>通过提供更具体的类型来进行抽象，从而隐藏内部类型，例如</li>
</ul>
<pre><code class="language-rust ignore">pub struct Foo(Bar&lt;T1, T2&gt;);
</code></pre>
<p>在这里<code>Bar</code>也许是一个公开的泛型，<code>T1</code>和<code>T2</code>是一些内部类型。我们模块的用户不应该知道我们通过<code>Bar</code>来实现<code>Foo</code>，但是我们真正想隐藏的是类型<code>T1</code>和<code>T2</code>，以及他们是如何被<code>Bar</code>使用的。</p>
<h2><a class="header" href="#参阅-11" id="参阅-11">参阅</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch19-04-advanced-types.html?highlight=newtype#using-the-newtype-pattern-for-type-safety-and-abstraction">Advanced Types in the book</a></li>
<li><a href="https://wiki.haskell.org/Newtype">Newtypes in Haskell</a></li>
<li><a href="https://doc.rust-lang.org/stable/book/ch19-04-advanced-types.html#creating-type-synonyms-with-type-aliases">Type aliases</a></li>
<li><a href="https://crates.io/crates/derive_more">derive_more</a>, a crate for deriving many
builtin traits on newtypes.</li>
<li><a href="https://www.worthe-it.co.za/blog/2020-10-31-newtype-pattern-in-rust.html">The Newtype Pattern In Rust</a></li>
</ul>
<h1><a class="header" href="#raii-守卫" id="raii-守卫">RAII 守卫</a></h1>
<h2><a class="header" href="#说明-24" id="说明-24">说明</a></h2>
<p><a href="https://zh.wikipedia.org/wiki/RAII">RAII</a>是个糟糕的名字，代表“资源获取即初始化”。该模式的本质是，资源的初始化在对象的构造函数中完成，以及确定性析构器。通过使用一个RAII对象作为一些资源的守卫，并且依赖类型系统确保访问始终要通过守卫对象，以此在Rust中扩展这种模式。</p>
<h2><a class="header" href="#代码示例-8" id="代码示例-8">代码示例</a></h2>
<p>互斥保护是std库中这种模式的经典示例（这是实际实现中的简化版本）：</p>
<pre><code class="language-rust ignore">use std::ops::Deref;

struct Foo {}

struct Mutex&lt;T&gt; {
    // We keep a reference to our data: T here.
    //..
}

struct MutexGuard&lt;'a, T: 'a&gt; {
    data: &amp;'a T,
    //..
}

// Locking the mutex is explicit.
impl&lt;T&gt; Mutex&lt;T&gt; {
    fn lock(&amp;self) -&gt; MutexGuard&lt;T&gt; {
        // Lock the underlying OS mutex.
        //..

        // MutexGuard keeps a reference to self
        MutexGuard {
            data: self,
            //..
        }
    }
}

// Destructor for unlocking the mutex.
impl&lt;'a, T&gt; Drop for MutexGuard&lt;'a, T&gt; {
    fn drop(&amp;mut self) {
        // Unlock the underlying OS mutex.
        //..
    }
}

// Implementing Deref means we can treat MutexGuard like a pointer to T.
impl&lt;'a, T&gt; Deref for MutexGuard&lt;'a, T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        self.data
    }
}

fn baz(x: Mutex&lt;Foo&gt;) {
    let xx = x.lock();
    xx.foo(); // foo is a method on Foo.
    // The borrow checker ensures we can't store a reference to the underlying
    // Foo which will outlive the guard xx.

    // x is unlocked when we exit this function and xx's destructor is executed.
}
</code></pre>
<h2><a class="header" href="#出发点-14" id="出发点-14">出发点</a></h2>
<p>当资源被使用后必须被销毁，RAII可以被用来实现确定性析构。如果在销毁后访问该资源是错误的，那么此模式可用于防止此类错误。</p>
<h2><a class="header" href="#优点-17" id="优点-17">优点</a></h2>
<p>防止使用未初始化资源和销毁后资源的错误。</p>
<h2><a class="header" href="#讨论-12" id="讨论-12">讨论</a></h2>
<p>RAII是确保资源被合适地析构或确定的实用模式。我们可以在Rust中使用借用检查器静态地防止析构后发生使用资源的错误。</p>
<p>借用检查器的核心目标是确保对数据的引用不能超过数据的生命周期。RAII守卫模式之所以有效，是因为守卫对象包含对底层资源的引用并且只暴露这样的引用。Rust确保了守卫不能比底层资源活的更长，并且由守卫控制的对资源的引用不能比守卫获得更长。要了解这是如何工作的，最好检查<code>deref</code>的签名不进行生命周期省略。</p>
<pre><code class="language-rust ignore">fn deref&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a T {
    //..
}
</code></pre>
<p>返回的资源引用有与<code>self</code>相同的生命周期(<code>'a'</code>)。借用检查器因此确保<code>T</code>的引用比<code>self</code>的声明周期要短。</p>
<p>注意实现<code>Deref</code>不是这个模式的核心部分，这只是为了在用守卫时更加符合人体工程学。对守卫实现一个<code>get</code>方法也一样可以。</p>
<h2><a class="header" href="#参阅-12" id="参阅-12">参阅</a></h2>
<p><a href="patterns/../idioms/dtor-finally.html">Finalisation in destructors idiom</a></p>
<p>RAII is a common pattern in C++: <a href="http://en.cppreference.com/w/cpp/language/raii">cppreference.com</a>,
<a href="https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">wikipedia</a>.</p>
<p><a href="https://doc.rust-lang.org/1.0.0/style/ownership/raii.html">Style guide entry</a>
(currently just a placeholder).</p>
<h1><a class="header" href="#偏爱更小的库" id="偏爱更小的库">偏爱更小的库</a></h1>
<h2><a class="header" href="#说明-25" id="说明-25">说明</a></h2>
<p>Prefer small crates that do one thing well.</p>
<p>偏向于使用专注于做好一件事的库。</p>
<p>Cargo和crate.io使得使用第三方库更简单，比C和C++在这一点上更强。此外，因为crates.io上的包发布后就不能编辑和撤销，任何发布在未来都要能够工作。我们应该采用这种工具的优点，并且使用更小的，更细粒度的依赖。</p>
<h2><a class="header" href="#优点-18" id="优点-18">优点</a></h2>
<ul>
<li>小的库更容易理解，并且鼓励更加模块化代码。</li>
<li>库支持在不同项目间重用代码。举例来说，<code>url</code>库是作为Servo浏览器引擎的一部分开发的，但是其也被广泛用于这个项目之外。由于Rust的编译单元是Crate，所以讲一个项目拆分为多个Crate可以允许并行编译更多的代码。</li>
</ul>
<h2><a class="header" href="#缺点-17" id="缺点-17">缺点</a></h2>
<ul>
<li>当一个项目依赖多个有矛盾版本的库时，会导致“依赖地狱”。举例来说，<code>url</code>库有0.5和1.0两个版本。由于<code>Url</code>在<code>url:1.0</code>中和<code>url:0.5</code>中是不同的类型，一个使用<code>url:0.5</code>的HTTP客户端不能接受使用<code>url:1.0</code>的网络爬虫传递的<code>Url</code>值。</li>
<li>在crates.io上的包时没有策划的。一个库可能写的不好，只有没有帮助的文档，或者是彻头彻尾的恶意代码。</li>
<li>两个小库可能比一个大的库的优化要更少，因为编译器默认没有开启链接时优化。</li>
</ul>
<h2><a class="header" href="#示例-7" id="示例-7">示例</a></h2>
<p><code>ref_slice</code>库提供转换<code>&amp;T</code>为<code>&amp;[T]</code>的函数。</p>
<p><code>url</code>库提供处理URL的工具。</p>
<p><code>num_cpus</code>库提供一个函数来查询机器上的CPU数量。</p>
<h2><a class="header" href="#see-also-1" id="see-also-1">See also</a></h2>
<ul>
<li><a href="https://crates.io/">crates.io: The Rust community crate host</a></li>
</ul>
<h1><a class="header" href="#策略模式" id="策略模式">策略模式</a></h1>
<h2><a class="header" href="#说明-26" id="说明-26">说明</a></h2>
<p><a href="https://en.wikipedia.org/wiki/Strategy_pattern">策略模式</a>是支持关注点分离的一门技术。 它还支持通过 <a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle">依赖倒置</a>来分离软件模块。</p>
<p>策略模式背后的基本思想是，给定一个解决特定问题的算法，我们仅在抽象层次上定义算法的框架，并将指定的算法实现分成不同的部分。</p>
<p>这样，使用该算法的客户端可以选择特定的实现，而通用的算法工作流可以保持不变。换句话说，类的抽象规范不依赖于派生类的具体实现，而是具体实现必须遵循抽象规范。这就是我们为什么叫它“依赖倒置”。</p>
<h2><a class="header" href="#出发点-15" id="出发点-15">出发点</a></h2>
<p>想象一下我们正在开发一个需要每个月生成报告的项目。我们需要用不同格式生成报告（不同策略）例如用<code>JSON</code>或者<code>富文本</code>。但是事物是在发展的，我们也不知道未来有什么需求。例如，我们也许需要用一种全新的格式生成报告，或者是修改我们已有的一种格式。</p>
<h2><a class="header" href="#代码示例-9" id="代码示例-9">代码示例</a></h2>
<p>在这个例子中我们的不变量（或者说抽象）是<code>Context</code>,<code>Formatter</code>和<code>Report</code>，同时<code>Text</code>和<code>Json</code>是我们的策略结构体。这些策略都要实现<code>Formatter</code>特性。</p>
<pre><pre class="playground"><code class="language-rust edition2018">use std::collections::HashMap;
type Data = HashMap&lt;String, u32&gt;;

trait Formatter {
    fn format(&amp;self, data: &amp;Data, s: &amp;mut String);
}

struct Report;

impl Report {
    fn generate&lt;T: Formatter&gt;(g: T, s: &amp;mut String) {
        // backend operations...
        let mut data = HashMap::new();
        data.insert(&quot;one&quot;.to_string(), 1);
        data.insert(&quot;two&quot;.to_string(), 2);
        // generate report
        g.format(&amp;data, s);
    }
}

struct Text;
impl Formatter for Text {
    fn format(&amp;self, data: &amp;Data, s: &amp;mut String) {
        *s = data
            .iter()
            .map(|(key, val)| format!(&quot;{} {}\n&quot;, key, val))
            .collect();
    }
}

struct Json;
impl Formatter for Json {
    fn format(&amp;self, data: &amp;Data, s: &amp;mut String) {
        *s = String::from(&quot;[&quot;);
        let mut iter = data.into_iter();
        if let Some((key, val)) = iter.next() {
            let entry = format!(r#&quot;{{&quot;{}&quot;:&quot;{}&quot;}}&quot;#, key, val);
            s.push_str(&amp;entry);
            while let Some((key, val)) = iter.next() {
                s.push(',');
                let entry = format!(r#&quot;{{&quot;{}&quot;:&quot;{}&quot;}}&quot;#, key, val);
                s.push_str(&amp;entry);
            }
        }
        s.push(']');
    }
}

fn main() {
    let mut s = String::from(&quot;&quot;);
    Report::generate(Text, &amp;mut s);
    assert!(s.contains(&quot;one 1&quot;));
    assert!(s.contains(&quot;two 2&quot;));

    Report::generate(Json, &amp;mut s);
    assert!(s.contains(r#&quot;{&quot;one&quot;:&quot;1&quot;}&quot;#));
    assert!(s.contains(r#&quot;{&quot;two&quot;:&quot;2&quot;}&quot;#));
}
</code></pre></pre>
<h2><a class="header" href="#优点-19" id="优点-19">优点</a></h2>
<p>主要的优点是分离关注点。举例来说，在这个例子里<code>Report</code>并不知道<code>Json</code>和<code>Text</code>的特定实现，尽管输出的实现并不关心数据是如何被预处理、存储和抓取的。它仅仅需要知道上下文和需要实现的特定的特性和方法，就像<code>Formatter</code>和<code>run</code>。</p>
<h2><a class="header" href="#缺点-18" id="缺点-18">缺点</a></h2>
<p>对于每个策略，必须至少实现一个模块，因此模块的数量会随着策略数量增加。如果有很多策略可供选择，那么用户就必须知道策略之间的区别。</p>
<h2><a class="header" href="#讨论-13" id="讨论-13">讨论</a></h2>
<p>在前面的例子中所有的策略实现都在一个文件中。提供不同策略的方式包括：</p>
<ul>
<li>所有都在一个文件中（如本例所示，类似于被分离为模块）</li>
<li>分离成模块，例如<code>formatter::json</code>模块、<code>formatter::text</code>模块</li>
<li>使用编译器特性标志，例如<code>json</code>特性、<code>text</code>特性</li>
<li>分离成不同的库，例如<code>json</code>库、<code>text</code>库</li>
</ul>
<p>Serde库是策略模式的一个实践的好例子。Serde通过手动实现<code>Serialize</code>和<code>Deserialize</code>特性支持<a href="https://serde.rs/custom-serialization.html">完全定制</a>化序列化的行为。例如，我们可以轻松替换<code>serde_json</code>为<code>serde_cbor</code>因为它们暴露相似的方法。有了它，库<code>serde_transcode</code>更有用和符合人体工程学。</p>
<p>不过，我们在Rust中不需要特性来实现这个模式。</p>
<p>下面这个玩具例子演示了用Rust的<code>闭包</code>来实现策略模式的思路：</p>
<pre><pre class="playground"><code class="language-rust edition2018">struct Adder;
impl Adder {
    pub fn add&lt;F&gt;(x: u8, y: u8, f: F) -&gt; u8
    where
        F: Fn(u8, u8) -&gt; u8,
    {
        f(x, y)
    }
}

fn main() {
    let arith_adder = |x, y| x + y;
    let bool_adder = |x, y| {
        if x == 1 || y == 1 {
            1
        } else {
            0
        }
    };
    let custom_adder = |x, y| 2 * x + y;

    assert_eq!(9, Adder::add(4, 5, arith_adder));
    assert_eq!(0, Adder::add(0, 0, bool_adder));
    assert_eq!(5, Adder::add(1, 3, custom_adder));
}

</code></pre></pre>
<p>事实上，Rust已经将这个思路用于<code>Option</code>的<code>map</code>方法：</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
    let val = Some(&quot;Rust&quot;);

    let len_strategy = |s: &amp;str| s.len();
    assert_eq!(4, val.map(len_strategy).unwrap());

    let first_byte_strategy = |s: &amp;str| s.bytes().next().unwrap();
    assert_eq!(82, val.map(first_byte_strategy).unwrap());
}
</code></pre></pre>
<h2><a class="header" href="#see-also-2" id="see-also-2">See also</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Strategy_pattern">策略模式</a></li>
<li><a href="https://en.wikipedia.org/wiki/Dependency_injection">依赖注入</a></li>
<li><a href="https://en.wikipedia.org/wiki/Modern_C++_Design#Policy-based_design">基于策略的设计</a></li>
</ul>
<h1><a class="header" href="#将不安全置于小模块中" id="将不安全置于小模块中">将不安全置于小模块中</a></h1>
<h2><a class="header" href="#说明-27" id="说明-27">说明</a></h2>
<p>如果你有<code>unsafe</code>代码，创建尽可能小的模块来支持所需的不变量，从而在不安全的基础上创建最小的安全接口。将其嵌入到只包含安全代码的较大模块中，并且提供一个符合人体工程学的接口。注意，外部模块可以包含直接调用不安全代码中的不安全函数和方法。用户可以此来获取性能提升。</p>
<h2><a class="header" href="#优点-20" id="优点-20">优点</a></h2>
<ul>
<li>限制了必须审核的不安全代码</li>
<li>编写外部模块要更容易，因为你可以依靠内部模块的安全保证。</li>
</ul>
<h2><a class="header" href="#缺点-19" id="缺点-19">缺点</a></h2>
<ul>
<li>有时，找一个合适的接口是很困难的。</li>
<li>抽象可能会降低效率。</li>
</ul>
<h2><a class="header" href="#示例-8" id="示例-8">示例</a></h2>
<ul>
<li><a href="https://docs.rs/toolshed"><code>toolshed</code></a>库将不安全操作放在了子模块中，提供了安全的接口给用户。<code>std</code>的<code>String</code>类是利用<code>Vec&lt;u8&gt;</code>封装加上内容必须是合法的UTF-8编码。<code>String</code>上的操作确保了这种行为。不过，用户也可以用不安全的方法来创建一个<code>String</code>，在这种情况下用户有责任保证内容的有效性。</li>
</ul>
<h2><a class="header" href="#参阅-13" id="参阅-13">参阅</a></h2>
<ul>
<li><a href="https://www.ralfj.de/blog/2018/08/22/two-kinds-of-invariants.html">Ralf Jung's Blog about invariants in unsafe code</a></li>
</ul>
<h1><a class="header" href="#访问者模式" id="访问者模式">访问者模式</a></h1>
<h2><a class="header" href="#说明-28" id="说明-28">说明</a></h2>
<p>访问者封装了在不同对象集合上运行的算法。它支持在不修改数据的情况下，支持不同算法。（或者它们的主要行为）</p>
<p>此外，访问者模式允许将对象集合的遍历与对每个对象执行的操作分离开来。</p>
<h2><a class="header" href="#代码示例-10" id="代码示例-10">代码示例</a></h2>
<pre><code class="language-rust ignore">// The data we will visit
mod ast {
    pub enum Stmt {
        Expr(Expr),
        Let(Name, Expr),
    }

    pub struct Name {
        value: String,
    }

    pub enum Expr {
        IntLit(i64),
        Add(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
        Sub(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
    }
}

// The abstract visitor
mod visit {
    use ast::*;

    pub trait Visitor&lt;T&gt; {
        fn visit_name(&amp;mut self, n: &amp;Name) -&gt; T;
        fn visit_stmt(&amp;mut self, s: &amp;Stmt) -&gt; T;
        fn visit_expr(&amp;mut self, e: &amp;Expr) -&gt; T;
    }
}

use visit::*;
use ast::*;

// An example concrete implementation - walks the AST interpreting it as code.
struct Interpreter;
impl Visitor&lt;i64&gt; for Interpreter {
    fn visit_name(&amp;mut self, n: &amp;Name) -&gt; i64 { panic!() }
    fn visit_stmt(&amp;mut self, s: &amp;Stmt) -&gt; i64 {
        match *s {
            Stmt::Expr(ref e) =&gt; self.visit_expr(e),
            Stmt::Let(..) =&gt; unimplemented!(),
        }
    }

    fn visit_expr(&amp;mut self, e: &amp;Expr) -&gt; i64 {
        match *e {
            Expr::IntLit(n) =&gt; n,
            Expr::Add(ref lhs, ref rhs) =&gt; self.visit_expr(lhs) + self.visit_expr(rhs),
            Expr::Sub(ref lhs, ref rhs) =&gt; self.visit_expr(lhs) - self.visit_expr(rhs),
        }
    }
}
</code></pre>
<p>可以实现更多的访问者，例如类型检查器，而不必修改AST数据。</p>
<h2><a class="header" href="#出发点-16" id="出发点-16">出发点</a></h2>
<p>当你想要讲一个算法用于不同数据的时候，访问器模式是很有用的。如果数据是相同种类的，你可以用一个类似迭代器模式。使用访问者对象（而不是函数式的方法）支持访问者带有状态，从而在节点之间传递信息。</p>
<h2><a class="header" href="#讨论-14" id="讨论-14">讨论</a></h2>
<p><code>visit_*</code>通常返回空值（与示例中的相反）。在这种情况下，可以将遍历代码分解出来并在算法之间共享。（并且提供空的默认方法）。在Rust中，通常的方法是对每种数据提供一个<code>walk_*</code>函数，例如：</p>
<pre><code class="language-rust ignore">pub fn walk_expr(visitor: &amp;mut Visitor, e: &amp;Expr) {
    match *e {
        Expr::IntLit(_) =&gt; {},
        Expr::Add(ref lhs, ref rhs) =&gt; {
            visitor.visit_expr(lhs);
            visitor.visit_expr(rhs);
        }
        Expr::Sub(ref lhs, ref rhs) =&gt; {
            visitor.visit_expr(lhs);
            visitor.visit_expr(rhs);
        }
    }
}
</code></pre>
<p>在其他语言中（例如Java）通常是数据提供一个<code>accept</code>方法来履行同样的职责。</p>
<h2><a class="header" href="#参阅-14" id="参阅-14">参阅</a></h2>
<p>访问者模式是面向对象语言中的一个常见模式。</p>
<p><a href="https://en.wikipedia.org/wiki/Visitor_pattern">访问者模式</a></p>
<p><a href="patterns/fold.html">fold</a>模式与访问者模式很相似，区别在于生成了被访问数据结构的新版本。</p>
<h1><a class="header" href="#反模式" id="反模式">反模式</a></h1>
<p><a href="https://en.wikipedia.org/wiki/Anti-pattern">反模式</a>是一种解决经常出现的问题的方案，但其通常是无效的并且风险颇高、适得其反。就像知道如何解决问题一样有价值的是知道不去解决它。反模式为我们提供了与设计模式相关的反例。反模式并不局限与代码。例如，进程也可以是一种反模式。</p>
<h1><a class="header" href="#denywarnings" id="denywarnings"><code>#![deny(warnings)]</code></a></h1>
<h2><a class="header" href="#说明-29" id="说明-29">说明</a></h2>
<p>一个善意的库作者想要确保他们的代码在编译时不会产生警告。因此他们在库里标注以下内容：</p>
<h2><a class="header" href="#示例-9" id="示例-9">示例</a></h2>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span>#![deny(warnings)]

<span class="boring">fn main() {
</span>// 一切安好
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#优点-21" id="优点-21">优点</a></h2>
<p>它很短，如果有什么错误就停止编译。</p>
<h2><a class="header" href="#缺点-20" id="缺点-20">缺点</a></h2>
<p>通过禁用编译器生成警告，库的作者放弃了Rust的稳定性。有时新的特性或者旧的不合格的特性需要被更改，因此，将会在一段宽限期内给出警告，之后变成禁用。</p>
<p>举例来说，一个类型可以有两个具有相同方法的实现。这被认为是一个坏主意，但是为了顺利过渡，引入 <code>overlapping-inherent-impls</code>提示来警告那些在将来版本中出现严重错误的人。</p>
<p>而且有时API会被弃用，所以使用它们会发出警告。</p>
<p>所有的这些在改变时都可能破坏编译过程。</p>
<p>此外，除非这个删除注释，否则不能再使用提供额外警告的库。（例如rust-clippy）这可以通过<a href="https://doc.rust-lang.org/rustc/lints/levels.html#capping-lints">--cap-lints</a>缓解。<code>--cap-lints=warn</code>命令行参数将所有的<code>deny</code>提示的错误转换为警告。但是请注意<code>forbid</code>警告比<code>deny</code>要更强，因此不能把<code>forbid</code>级别的提示改写为低于错误的任何级别。因此，<code>forbid</code>提示仍将停止编译。</p>
<h2><a class="header" href="#替代方案" id="替代方案">替代方案</a></h2>
<p>解决这个问题有两种方法：第一种，我们可以将编译设置与代码解耦；第二种，我们可以显式地命名要拒绝的警告。</p>
<p>下面这个命令行参数将会带着所有关闭的警告进行编译：</p>
<p><code>RUSTFLAGS=&quot;-D warnings&quot; cargo build</code></p>
<p>任何独立开发者都可以这样做（或者设置到持续集成工具，如Travis，但是记住当某些内容发生变化时，可能会破坏编译）。</p>
<p>或者，我们可以指定我们想要在代码中关闭的警告。下面是警告提示列表（Rustc 1.48.0）：</p>
<pre><code class="language-rust ignore">#[deny(bad-style,
       const-err,
       dead-code,
       improper-ctypes,
       non-shorthand-field-patterns,
       no-mangle-generic-items,
       overflowing-literals,
       path-statements ,
       patterns-in-fns-without-body,
       private-in-public,
       unconditional-recursion,
       unused,
       unused-allocation,
       unused-comparisons,
       unused-parens,
       while-true)]
</code></pre>
<p>此外，下面的提示是推荐关闭的：</p>
<pre><code class="language-rust ignore">#[deny(missing-debug-implementations,
       missing-docs,
       trivial-casts,
       trivial-numeric-casts,
       unused-extern-crates,
       unused-import-braces,
       unused-qualifications,
       unused-results)]
</code></pre>
<p>有时可能需要增加<code>missing-copy-implementations</code>到清单中。</p>
<p>请注意，我们没有关闭<code>deprecated</code>提示，因为可以肯定的是，将来会有更多不推荐的API。</p>
<h2><a class="header" href="#参阅-15" id="参阅-15">参阅</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/reference/attributes.html#deprecation">deprecate attribute</a> documentation</li>
<li>Type <code>rustc -W help</code> for a list of lints on your system. Also type
<code>rustc --help</code> for a general list of options</li>
<li><a href="https://github.com/Manishearth/rust-clippy">rust-clippy</a> is a collection of lints for better Rust code</li>
</ul>
<h1><a class="header" href="#deref-多态" id="deref-多态"><code>Deref</code> 多态</a></h1>
<h2><a class="header" href="#说明-30" id="说明-30">说明</a></h2>
<p>滥用<code>Deref</code>特性来模拟结构体之间的继承，从而重用方法。</p>
<h2><a class="header" href="#代码示例-11" id="代码示例-11">代码示例</a></h2>
<p>有时我们想要从诸如Java之类的面向对象语言中模拟以下常见模式：</p>
<pre><code class="language-java">class Foo {
    void m() { ... }
}

class Bar extends Foo {}

public static void main(String[] args) {
    Bar b = new Bar();
    b.m();
}
</code></pre>
<p>我们可以用deref多态反模式来实现：</p>
<pre><code class="language-rust ignore">use std::ops::Deref;

struct Foo {}

impl Foo {
    fn m(&amp;self) {
        //..
    }

}

struct Bar {
    f: Foo
}

impl Deref for Bar {
    type Target = Foo;
    fn deref(&amp;self) -&gt; &amp;Foo {
        &amp;self.f
    }
}

fn main() {
    let b = Bar { Foo {} };
    b.m();
}
</code></pre>
<p>Rust中没有结构体的继承。取而代之的是我们使用组合方式在<code>Bar</code>内包含<code>Foo</code>（因为字段是一个值，它在内部存储），因此它们都是字段，拥有和Java版本相同的内存布局。（如果你想要确保这一点，可以用<code>#[repr(C)]</code>）。</p>
<p>为了使方法调用有效，我们为<code>Bar</code>实现了<code>Deref</code>特性，生成目标为<code>Foo</code>（返回的是内置的<code>Foo</code>字段）。这就相当于当我们对<code>Bar</code>解引用的时候我们就会获取到一个<code>Foo</code>对象。这是非常诡异的，解引用通常是通过一个类型的引用获取这个类型的值，然而这里却是两种不相关的类型。不过，因为点运算符是隐式的解引用，所以方法调用时也将搜索<code>Foo</code>类型的方法。</p>
<h2><a class="header" href="#优点-22" id="优点-22">优点</a></h2>
<p>节省了一些样板代码，例如：</p>
<pre><code class="language-rust ignore">impl Bar {
    fn m(&amp;self) {
        self.f.m()
    }
}
</code></pre>
<h2><a class="header" href="#缺点-21" id="缺点-21">缺点</a></h2>
<p>最重要的是这是一个令人惊讶的习惯用法——未来的程序员在阅读这些代码时不会期望发生这种情况。这是因为我们滥用了<code>Deref</code>特性，而不是按预期的那样去使用。同时也是因为这里的机制是完全隐式的。</p>
<p>这种模式并没有实现像Java或者C++里的继承。此外，对<code>Foo</code>实现的特性也不会自动地适用于<code>Boo</code>，所以这种模式对于边界检查和泛型编程来说非常差。</p>
<p>使用这种模式，就<code>self</code>而言，给出了与大多数面向对象语言截然不同的语义。通常它仍是子类型的引用，在这种模式下它将是定义方法的“类”。</p>
<p>最后，这种模式仅支持单继承，并且没有接口的概念、基于类的隐私性或者其他的与继承相关的特性。因此，对于习惯于Java那种继承的程序员来说，它提供了一种“惊喜”。</p>
<h2><a class="header" href="#讨论-15" id="讨论-15">讨论</a></h2>
<p>这没有好的替代方案。根据具体情况，最好用特性重新实现，或者手动编写分发给<code>Foo</code>的方法。我们确实打算为Rust添加一种像这样的继承机制，但是可能需要一段时间才能进入稳定版本的Rust。看这些 <a href="http://aturon.github.io/blog/2015/09/18/reuse/">博客</a>、<a href="http://smallcultfollowing.com/babysteps/blog/2015/10/08/virtual-structs-part-4-extended-enums-and-thin-traits/">文章</a> 和这个<a href="https://github.com/rust-lang/rfcs/issues/349">RFC issue</a> 来了解更多细节。</p>
<p><code>Deref</code>特性是被设计用来实现自定义指针类型的。它的用处是将<code>T</code>的引用转变为<code>T</code>的值，而不是在类型间转换。遗憾的是，这不是（或者说无法）靠特性定义来强制执行。</p>
<p>Rust尝试在显式和隐式机制之间做出权衡，更偏向于类型间进行显式转换。点运算符自动解引用是出于符合人体工程学的角度做的隐式设计，其目的仅限于有限的间接程度，而不是任意类型之间做隐式转换。</p>
<h2><a class="header" href="#参阅-16" id="参阅-16">参阅</a></h2>
<ul>
<li><a href="anti_patterns/../idioms/deref.html">Collections are smart pointers idiom</a>.</li>
<li>Delegation crates for less boilerplate like <a href="https://crates.io/crates/delegate">delegate</a>
or <a href="https://crates.io/crates/ambassador">ambassador</a></li>
<li><a href="https://doc.rust-lang.org/std/ops/trait.Deref.html">Documentation for <code>Deref</code> trait</a>.</li>
</ul>
<h1><a class="header" href="#rust中函数式用法" id="rust中函数式用法">Rust中函数式用法</a></h1>
<p>Rust是一种命令式语言，但是它也遵循很多<a href="https://en.wikipedia.org/wiki/Functional_programming">函数式语言</a> 的范式。</p>
<blockquote>
<p>在计算机科学中，函数式编程是一种通过应用和组合函数来编程的一种范式。它是一种声明式编程范式，其中函数的定义是每个表达式返回一个值的表达式树，而不是一系列改变程序状态的命令语句。</p>
</blockquote>
<h1><a class="header" href="#编程范式" id="编程范式">编程范式</a></h1>
<p>当出于一个命令式的背景时，理解函数式程序最大的障碍之一就是思维的转变。命令式程序说明了如何做，然而声明式程序说明做了什么。让我们用对1到10求和的例子来说明这一点。</p>
<h2><a class="header" href="#命令式" id="命令式">命令式</a></h2>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut sum = 0;
for i in 1..11 {
    sum += i;
}
println!(&quot;{}&quot;, sum);
<span class="boring">}
</span></code></pre></pre>
<p>在命令式程序中，我们必须用编译器来查看发生了什么。这里<code>sum</code>起始为0，然后我们在1到10范围内循环，每次循环中我们加上对应的值，最后输出。</p>
<table><thead><tr><th align="center"><code>i</code></th><th align="center"><code>sum</code></th></tr></thead><tbody>
<tr><td align="center">1</td><td align="center">1</td></tr>
<tr><td align="center">2</td><td align="center">3</td></tr>
<tr><td align="center">3</td><td align="center">6</td></tr>
<tr><td align="center">4</td><td align="center">10</td></tr>
<tr><td align="center">5</td><td align="center">15</td></tr>
<tr><td align="center">6</td><td align="center">21</td></tr>
<tr><td align="center">7</td><td align="center">28</td></tr>
<tr><td align="center">8</td><td align="center">36</td></tr>
<tr><td align="center">9</td><td align="center">45</td></tr>
<tr><td align="center">10</td><td align="center">55</td></tr>
</tbody></table>
<p>这就是我们大多数人开始编程的方式。我们了解到程序是一些操作步骤的集合。</p>
<h2><a class="header" href="#声明式" id="声明式">声明式</a></h2>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;{}&quot;, (1..11).fold(0, |a, b| a + b));
<span class="boring">}
</span></code></pre></pre>
<p>哇哦！这真是不一样！这里发生了啥？记住声明式程序说明了做了什么，而不是如何去做。<code>fold</code>是一个 <a href="https://en.wikipedia.org/wiki/Function_composition">组合</a>函数的函数。这个名字来自于Haskell。</p>
<p>这里，我们组合了在1到10范围内的加法函数（闭包<code>|a,b| a + b</code>）。<code>0</code>是起始点，所以<code>a</code>最开始是<code>0</code>，<code>b</code>是范围的第一个元素<code>1</code>。结果是
<code>0 + 1 = 1</code>。所以现在我们再次<code>fold</code>，<code>a = 1</code>、<code>b = 2</code>下一个结果是<code>1 + 2 = 3</code>。这个过程一直持续到范围内最后一个元素<code>10</code>。</p>
<table><thead><tr><th align="center"><code>a</code></th><th align="center"><code>b</code></th><th align="center">result</th></tr></thead><tbody>
<tr><td align="center">0</td><td align="center">1</td><td align="center">1</td></tr>
<tr><td align="center">1</td><td align="center">2</td><td align="center">3</td></tr>
<tr><td align="center">3</td><td align="center">3</td><td align="center">6</td></tr>
<tr><td align="center">6</td><td align="center">4</td><td align="center">10</td></tr>
<tr><td align="center">10</td><td align="center">5</td><td align="center">15</td></tr>
<tr><td align="center">15</td><td align="center">6</td><td align="center">21</td></tr>
<tr><td align="center">21</td><td align="center">7</td><td align="center">28</td></tr>
<tr><td align="center">28</td><td align="center">8</td><td align="center">36</td></tr>
<tr><td align="center">36</td><td align="center">9</td><td align="center">45</td></tr>
<tr><td align="center">45</td><td align="center">10</td><td align="center">55</td></tr>
</tbody></table>
<h1><a class="header" href="#补充材料" id="补充材料">补充材料</a></h1>
<p>补充有用内容的集合</p>
<h2><a class="header" href="#演讲" id="演讲">演讲</a></h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=Pm_oO0N5B9k">Design Patterns in Rust</a> by
Nicholas Cameron at the PDRust (2016)</li>
<li><a href="https://www.youtube.com/watch?v=0zOg8_B71gE">Writing Idiomatic Libraries in Rust</a>
by Pascal Hertleif at RustFest (2017)</li>
<li><a href="https://www.youtube.com/watch?v=vqavdUGKeb4">Rust Programming Techniques</a> by
Nicholas Cameron at LinuxConfAu (2018)</li>
</ul>
<h2><a class="header" href="#书在线" id="书在线">书(在线)</a></h2>
<ul>
<li><a href="https://rust-lang.github.io/api-guidelines">The Rust API Guidelines</a></li>
</ul>
<h1><a class="header" href="#设计原则" id="设计原则">设计原则</a></h1>
<h2><a class="header" href="#常见设计原则概述" id="常见设计原则概述">常见设计原则概述</a></h2>
<hr />
<h2><a class="header" href="#a-hrefhttpsenwikipediaorgwikisolidsolida" id="a-hrefhttpsenwikipediaorgwikisolidsolida"><a href="https://en.wikipedia.org/wiki/SOLID">SOLID</a></a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Single-responsibility_principle">单一权责原则Single Responsibility Principle (SRP)</a>:
一个类只应有一种责任，只有对软件中特定的一部分修改时才会影响到类。</li>
<li><a href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle">开闭原则Open/Closed Principle (OCP)</a>:
软件应该对扩展开放，但是对修改封闭。</li>
<li><a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle">里氏替换原则Liskov Substitution Principle (LSP)</a>:
子类可以扩展父类的功能，但不能改变父类原有的功能</li>
<li><a href="https://en.wikipedia.org/wiki/Interface_segregation_principle">接口隔离原则Interface Segregation Principle (ISP)</a>:
多个专一功能的接口比一个泛用的接口要好。</li>
<li><a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle">依赖倒置原则Dependency Inversion Principle (DIP)</a>:
应该依赖抽象而不是依赖于细节。</li>
</ul>
<h2><a class="header" href="#a-hrefhttpsenwikipediaorgwikidon27t_repeat_yourselfdry-dont-repeat-yourselfa" id="a-hrefhttpsenwikipediaorgwikidon27t_repeat_yourselfdry-dont-repeat-yourselfa"><a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY (Don’t Repeat Yourself)</a></a></h2>
<p>在一个系统中，每一个知识都必须有一个单一、明确、权威的表示。</p>
<h2><a class="header" href="#a-hrefhttpsenwikipediaorgwikikiss_principlekiss原则kiss-principlea" id="a-hrefhttpsenwikipediaorgwikikiss_principlekiss原则kiss-principlea"><a href="https://en.wikipedia.org/wiki/KISS_principle">KISS原则KISS principle</a></a></h2>
<p>绝大多数系统简单时比复杂时工作的要好。因此简单性是设计中的关键目标，并且应该避免不必要的复杂性。</p>
<h2><a class="header" href="#a-hrefhttpsenwikipediaorgwikilaw_of_demeter迪米特法则law-of-demeter-loda" id="a-hrefhttpsenwikipediaorgwikilaw_of_demeter迪米特法则law-of-demeter-loda"><a href="https://en.wikipedia.org/wiki/Law_of_Demeter">迪米特法则Law of Demeter (LoD)</a></a></h2>
<p>一个实体应该尽可能少的与任何其他的结构或者特性（包括子组件）发生关系，符合“信息隐藏”的原则。</p>
<h2><a class="header" href="#a-hrefhttpsenwikipediaorgwikidesign_by_contract契约式设计design-by-contract-dbca" id="a-hrefhttpsenwikipediaorgwikidesign_by_contract契约式设计design-by-contract-dbca"><a href="https://en.wikipedia.org/wiki/Design_by_contract">契约式设计Design by contract (DbC)</a></a></h2>
<p>软件设计者应该为软件组件定义规范、准确和可验证的接口，扩展了抽象数据类型的平凡定义，包括前置条件、后置条件和不变量。</p>
<h2><a class="header" href="#a-hrefhttpsenwikipediaorgwikiencapsulation_computer_programming封装encapsulationa" id="a-hrefhttpsenwikipediaorgwikiencapsulation_computer_programming封装encapsulationa"><a href="https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)">封装Encapsulation</a></a></h2>
<p>将数据与对该数据进行操作的方法捆绑在一起，或者限制对对象某些组件的直接访问。封装用于隐藏类中结构体对象的值或状态，防止未经授权地直接访问它们。</p>
<h2><a class="header" href="#a-hrefhttpsenwikipediaorgwikicommande28093query_separation命令查询分离原则command-query-separationcqsa" id="a-hrefhttpsenwikipediaorgwikicommande28093query_separation命令查询分离原则command-query-separationcqsa"><a href="https://en.wikipedia.org/wiki/Command%E2%80%93query_separation">命令查询分离原则Command-Query-Separation(CQS)</a></a></h2>
<p>函数不应该产生抽象的副作用，只允许命令（过程）产生副作用——Bertrand Meyer:《面向对象软件构造》</p>
<h2><a class="header" href="#a-hrefhttpsenwikipediaorgwikiprinciple_of_least_astonishment最小惊奇原则principle-of-least-astonishment-polaa" id="a-hrefhttpsenwikipediaorgwikiprinciple_of_least_astonishment最小惊奇原则principle-of-least-astonishment-polaa"><a href="https://en.wikipedia.org/wiki/Principle_of_least_astonishment">最小惊奇原则Principle of least astonishment (POLA)</a></a></h2>
<p>系统的组件应该像人们期望的那样工作，而不应该给用户一个惊奇。</p>
<h2><a class="header" href="#语言模块单元linguistic-modular-units" id="语言模块单元linguistic-modular-units">语言模块单元Linguistic-Modular-Units</a></h2>
<p>模块必须与使用的语言单元相符合——Bertrand Meyer:《面向对象软件构造》</p>
<h2><a class="header" href="#自文档self-documentation" id="自文档self-documentation">自文档Self-Documentation</a></h2>
<p>一个模块的设计者应该努力使所有关于该模块的信息成为模块本身的一部分——Bertrand Meyer:《面向对象软件构造》</p>
<h2><a class="header" href="#统一访问原则uniform-access" id="统一访问原则uniform-access">统一访问原则Uniform-Access</a></h2>
<p>一个模块提供的所有服务都应该通过一个统一的符号来提供，而这个符号并不表明它们是通过存储还是通过计算来实现的。——Bertrand Meyer:《面向对象软件构造》</p>
<h2><a class="header" href="#单一选择single-choice" id="单一选择single-choice">单一选择Single-Choice</a></h2>
<p>每当软件系统必须支持一组备选方案时，系统中应该只有一个模块知道它们的底细。——Bertrand Meyer:《面向对象软件构造》</p>
<h2><a class="header" href="#存储闭包persistence-closure" id="存储闭包persistence-closure">存储闭包Persistence-Closure</a></h2>
<p>当存储一个对象时，必须将其所依赖的部分一起存储。每当检索机制检索以前存储的对象时，它还必须检索该对象的尚未检索到的所有依赖项。——Bertrand Meyer:《面向对象软件构造》</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
