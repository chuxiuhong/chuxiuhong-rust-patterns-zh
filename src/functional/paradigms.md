# 编程范式

从命令式编程背景转向理解函数式程序时，最大的障碍之一是思维方式的转变。命令式程序描述**如何**做某事，而声明式程序描述**要做什么**。让我们通过计算1到10的数字之和来展示这一点。

## 命令式

```rust
let mut sum = 0;
for i in 1..11 {
    sum += i;
}
println!("{sum}");
```

在命令式程序中，我们必须像编译器一样思考来理解程序的执行过程。在这里，我们从`sum`为`0`开始。接下来，我们遍历1到10的范围。在每次循环中，我们将范围中的对应值加到总和中。最后打印结果。

| `i` | `sum` |
| :-: | :---: |
|  1  |   1   |
|  2  |   3   |
|  3  |   6   |
|  4  |  10   |
|  5  |  15   |
|  6  |  21   |
|  7  |  28   |
|  8  |  36   |
|  9  |  45   |
| 10  |  55   |

这是大多数人开始编程时的方式。我们学习到程序是一系列步骤的集合。

## 声明式

```rust
println!("{}", (1..11).fold(0, |a, b| a + b));
```

哇！这看起来真的很不一样！这里发生了什么？请记住，在声明式程序中，我们描述的是**要做什么**，而不是**如何做**。`fold`是一个[组合](https://en.wikipedia.org/wiki/Function_composition)函数的函数。这个命名约定来自Haskell。

在这里，我们将加法函数（这个闭包：`|a, b| a + b`）与1到10的范围组合在一起。`0`是起始点，所以`a`最初是`0`。`b`是范围中的第一个元素`1`。`0 + 1 = 1`是第一次计算的结果。然后我们再次`fold`，这时`a = 1`，`b = 2`，所以`1 + 2 = 3`是下一个结果。这个过程继续进行，直到我们到达范围中的最后一个元素`10`。

| `a` | `b` | result |
| :-: | :-: | :----: |
|  0  |  1  |   1    |
|  1  |  2  |   3    |
|  3  |  3  |   6    |
|  6  |  4  |   10   |
| 10  |  5  |   15   |
| 15  |  6  |   21   |
| 21  |  7  |   28   |
| 28  |  8  |   36   |
| 36  |  9  |   45   |
| 45  | 10  |   55   |
