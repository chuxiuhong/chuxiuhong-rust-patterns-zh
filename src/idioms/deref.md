# 集合类型作为智能指针

## 描述

使用 [`Deref`](https://doc.rust-lang.org/std/ops/trait.Deref.html) trait 来将集合类型视为智能指针，从而提供数据的所有权视图和借用视图。

## 示例

```rust,ignore
use std::ops::Deref;

struct Vec<T> {
    data: RawVec<T>,
    //..
}

impl<T> Deref for Vec<T> {
    type Target = [T];

    fn deref(&self) -> &[T] {
        //..
    }
}
```

`Vec<T>` 是一个拥有 `T` 类型元素所有权的集合，而切片（`&[T]`）则是 `T` 类型元素的借用集合。为 `Vec` 实现 `Deref` 允许从 `&Vec<T>` 到 `&[T]` 的隐式解引用，并在自动解引用搜索中包含这种关系。你可能期望在 `Vec` 上实现的大多数方法实际上是在切片上实现的。

同样地，`String` 和 `&str` 也具有类似的关系。

## 动机

所有权和借用是 Rust 语言的核心概念。数据结构必须正确处理这些语义以提供良好的用户体验。当实现一个拥有数据所有权的数据结构时，提供该数据的借用视图可以使 API 更加灵活。

## 优点

大多数方法只需要为借用视图实现一次，就可以通过解引用自动应用于所有权视图。

为客户端代码提供了选择借用或获取数据所有权的灵活性。

## 缺点

通过解引用获得的方法和 trait 在进行 bounds 检查时不会被考虑在内，因此使用这种模式的数据结构进行泛型编程可能会变得复杂（参见 `Borrow` 和 `AsRef` trait 等）。

## 讨论

智能指针和集合是类似的：智能指针指向单个对象，而集合指向多个对象。从类型系统的角度来看，两者之间几乎没有区别。如果只能通过集合访问每个数据，且集合负责删除数据（即使在共享所有权的情况下，某种借用视图可能也是合适的），那么就可以说这个集合拥有其数据的所有权。如果集合拥有其数据的所有权，通常提供数据的借用视图是很有用的，这样可以多次引用数据。

大多数智能指针（例如 `Foo<T>`）实现 `Deref<Target=T>`。然而，集合通常会解引用到一个自定义类型。`[T]` 和 `str` 有语言层面的支持，但在一般情况下这并不必要。`Foo<T>` 可以实现 `Deref<Target=Bar<T>`，其中 `Bar` 是一个动态大小类型，而 `&Bar<T>` 是 `Foo<T>` 中数据的借用视图。

通常，有序集合会为 `Range` 实现 `Index` 以提供切片语法。目标类型将是借用视图。

## 另请参阅

- [Deref 多态反模式](../anti_patterns/deref.md)
- [Deref trait 的文档](https://doc.rust-lang.org/std/ops/trait.Deref.html)
