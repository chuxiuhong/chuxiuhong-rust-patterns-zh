# 在析构函数中实现终止处理

## 描述

Rust 没有提供类似于 `finally` 块的功能（即无论函数如何退出都会执行的代码）。作为替代方案，可以使用对象的析构函数来运行必须在退出前执行的代码。

## 示例

```rust,ignore
fn baz() -> Result<(), ()> {
    // some code
}

fn bar() -> Result<(), ()> {
    // 这些不需要在函数内部定义
    struct Foo;

    // 为 Foo 实现析构函数
    impl Drop for Foo {
        fn drop(&mut self) {
            println!("exit");
        }
    }

    // 无论函数 `bar` 如何退出，_exit 的析构函数都会运行
    let _exit = Foo;
    // 使用 `?` 运算符进行隐式返回
    baz()?;
    // 正常返回
    Ok(())
}
```

## 动机

如果一个函数有多个返回点，那么在退出时执行代码就会变得困难且重复（因此容易出错）。在使用宏导致隐式返回的情况下尤其如此。一个常见的例子是 `?` 运算符，它在结果为 `Err` 时返回，在结果为 `Ok` 时继续执行。`?` 被用作异常处理机制，但与 Java（有 `finally`）不同，Rust 没有办法安排在正常和异常情况下都执行的代码。panic 也会导致函数提前退出。

## 优点

析构函数中的代码（几乎）总是会运行 - 可以处理 panic、提前返回等情况。

## 缺点

不能保证析构函数一定会运行。例如，如果函数中存在无限循环，或者程序在退出前崩溃。在已经发生 panic 的线程中再次发生 panic 时，析构函数也不会运行。因此，当绝对需要确保终止处理发生时，不能完全依赖析构函数。

这种模式引入了一些难以注意到的隐式代码。阅读函数时，并不能清楚地看出在退出时要运行哪些析构函数。这可能会使调试变得困难。

仅仅为了终止处理而需要一个对象和 `Drop` 实现，这样的样板代码有些重。

## 讨论

关于如何准确存储用作终止处理器的对象，有一些细节需要注意。它必须保持存活直到函数结束，然后被销毁。对象必须是一个值或唯一拥有的指针（例如 `Box<Foo>`）。如果使用共享指针（如 `Rc`），则终止处理器可能会在函数生命周期之外继续存活。出于类似原因，终止处理器不应该被移动或返回。

终止处理器必须被赋值给一个变量，否则它会立即被销毁，而不是在作用域结束时被销毁。如果变量仅用作终止处理器，则变量名必须以 `_` 开头，否则编译器会警告终止处理器从未被使用。但是不要将变量命名为单独的 `_` - 这种情况下它会立即被销毁。

在 Rust 中，当对象离开作用域时会运行析构函数。这种情况会发生在我们到达代码块末尾、提前返回或程序发生 panic 时。当发生 panic 时，Rust 会展开栈，运行每个栈帧中每个对象的析构函数。因此，即使 panic 发生在被调用的函数中，析构函数也会被调用。

如果在展开过程中析构函数发生 panic，没有好的处理方式，所以 Rust 会立即中止线程，不再运行其他析构函数。这意味着析构函数并不能绝对保证会运行。这也意味着你必须在析构函数中格外小心，避免 panic，因为它可能会使资源处于意外状态。

## 另请参阅

[RAII guards](../patterns/behavioural/RAII.md)。
